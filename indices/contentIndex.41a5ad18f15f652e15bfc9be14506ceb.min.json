{"/":{"title":"Introdu√ß√£o","content":"\n\nEste √© um rascunho de notas de aula para os conte√∫dos relacionados a:\n\n- [[vault/calculo-numerico/Vis√£o geral de c√°lculo num√©rico |C√°lculo Num√©rico]]\n- [[vault/estrutura-dados/Vis√£o geral de estrutura de dados|Estrutura de Dados]]\n- [[vault/Otimiza√ß√£o/Vis√£o geral de otimiza√ß√£o|Otimiza√ß√£o linear e inteira]]\n\n\n","lastmodified":"2022-10-19T15:09:54.7427337Z","tags":null},"/notes/CJK-+-Latex-Support-%E6%B5%8B%E8%AF%95":{"title":"CJK + Latex Support (ÊµãËØï)","content":"\n## Chinese, Japanese, Korean Support\nÂá†‰πéÂú®Êàë‰ª¨ÊÑèËØÜÂà∞‰πãÂâçÔºåÊàë‰ª¨Â∑≤ÁªèÁ¶ªÂºÄ‰∫ÜÂú∞Èù¢„ÄÇ\n\nÏö∞Î¶¨Í∞Ä Í∑∏Í≤ÉÏùÑ ÏïåÍ∏∞ÎèÑ Ï†ÑÏóê Ïö∞Î¶¨Îäî ÎïÖÏùÑ Îñ†ÎÇ¨ÏäµÎãàÎã§.\n\nÁßÅ„Åü„Å°„Åå„Åù„Çå„ÇíÁü•„Çã„Åª„ÅºÂâç„Å´„ÄÅÁßÅ„Åü„Å°„ÅØÂú∞Èù¢„ÇíÈõ¢„Çå„Å¶„ÅÑ„Åæ„Åó„Åü„ÄÇ\n\n## Latex\n\nBlock math works with two dollar signs `$$...$$`\n\n$$f(x) = \\int_{-\\infty}^\\infty\n    f\\hat(\\xi),e^{2 \\pi i \\xi x}\n    \\,d\\xi$$\n\t\nInline math also works with single dollar signs `$...$`. For example, Euler's identity but inline: $e^{i\\pi} = 0$\n\nAligned equations work quite well:\n\n$$\n\\begin{aligned}\na \u0026= b + c \\\\ \u0026= e + f \\\\\n\\end{aligned}\n$$\n\nAnd matrices\n\n$$\n\\begin{bmatrix}\n1 \u0026 2 \u0026 3 \\\\\na \u0026 b \u0026 c\n\\end{bmatrix}\n$$\n\n## RTL\nMore information on configuring RTL languages like Arabic in the [config](notes/config.md) page.\n","lastmodified":"2022-10-19T15:09:54.746733418Z","tags":null},"/notes/callouts":{"title":"Callouts","content":"\n## Callout support\n\nQuartz supports the same Admonition-callout syntax as Obsidian.\n\nThis includes\n- 12 Distinct callout types (each with several aliases)\n- Collapsable callouts\n\nSee [documentation on supported types and syntax here](https://help.obsidian.md/How+to/Use+callouts#Types).\n\n## Showcase\n\n\u003e [!EXAMPLE] Examples\n\u003e\n\u003e Aliases: example\n\n\u003e [!note] Notes\n\u003e\n\u003e Aliases: note\n\n\u003e [!abstract] Summaries \n\u003e\n\u003e Aliases: abstract, summary, tldr\n\n\u003e [!info] Info \n\u003e\n\u003e Aliases: info, todo\n\n\u003e [!tip] Hint \n\u003e\n\u003e Aliases: tip, hint, important\n\n\u003e [!success] Success \n\u003e\n\u003e Aliases: success, check, done\n\n\u003e [!question] Question \n\u003e\n\u003e Aliases: question, help, faq\n\n\u003e [!warning] Warning \n\u003e\n\u003e Aliases: warning, caution, attention\n\n\u003e [!failure] Failure \n\u003e\n\u003e Aliases: failure, fail, missing\n\n\u003e [!danger] Error\n\u003e\n\u003e Aliases: danger, error\n\n\u003e [!bug] Bug\n\u003e\n\u003e Aliases: bug\n\n\u003e [!quote] Quote\n\u003e\n\u003e Aliases: quote, cite\n","lastmodified":"2022-10-19T15:09:54.746733418Z","tags":null},"/notes/config":{"title":"Configuration","content":"\n## Configuration\nQuartz is designed to be extremely configurable. You can find the bulk of the configuration scattered throughout the repository depending on how in-depth you'd like to get.\n\nThe majority of configuration can be found under `data/config.yaml`. An annotated example configuration is shown below.\n\n```yaml {title=\"data/config.yaml\"}\n# The name to display in the footer\nname: Jacky Zhao\n\n# whether to globally show the table of contents on each page\n# this can be turned off on a per-page basis by adding this to the\n# front-matter of that note\nenableToc: true\n\n# whether to by-default open or close the table of contents on each page\nopenToc: false\n\n# whether to display on-hover link preview cards\nenableLinkPreview: true\n\n# whether to render titles for code blocks\nenableCodeBlockTitle: true \n\n# whether to render copy buttons for code blocks\nenableCodeBlockCopy: true \n\n# whether to render callouts\nenableCallouts: true\n\n# whether to try to process Latex\nenableLatex: true\n\n# whether to enable single-page-app style rendering\n# this prevents flashes of unstyled content and improves\n# smoothness of Quartz. More info in issue #109 on GitHub\nenableSPA: true\n\n# whether to render a footer\nenableFooter: true\n\n# whether backlinks of pages should show the context in which\n# they were mentioned\nenableContextualBacklinks: true\n\n# whether to show a section of recent notes on the home page\nenableRecentNotes: false\n\n# whether to display an 'edit' button next to the last edited field\n# that links to github\nenableGitHubEdit: true\nGitHubLink: https://github.com/jackyzha0/quartz/tree/hugo/content\n\n# whether to use Operand to power semantic search\n# IMPORTANT: replace this API key with your own if you plan on using\n# Operand search!\nenableSemanticSearch: false\noperandApiKey: \"REPLACE-WITH-YOUR-OPERAND-API-KEY\"\n\n# page description used for SEO\ndescription:\n  Host your second brain and digital garden for free. Quartz features extremely fast full-text search,\n  Wikilink support, backlinks, local graph, tags, and link previews.\n\n# title of the home page (also for SEO)\npage_title:\n  \"ü™¥ Quartz 3.2\"\n\n# links to show in the footer\nlinks:\n  - link_name: Twitter\n    link: https://twitter.com/_jzhao\n  - link_name: Github\n    link: https://github.com/jackyzha0\n```\n\n### Code Block Titles\nTo add code block titles with Quartz:\n\n1. Ensure that code block titles are enabled in Quartz's configuration:\n\n    ```yaml {title=\"data/config.yaml\", linenos=false}\n    enableCodeBlockTitle: true\n    ```\n\n2. Add the `title` attribute to the desired [code block\n   fence](https://gohugo.io/content-management/syntax-highlighting/#highlighting-in-code-fences):\n\n      ```markdown {linenos=false}\n       ```yaml {title=\"data/config.yaml\"}\n       enableCodeBlockTitle: true  # example from step 1\n       ```\n      ```\n\n**Note** that if `{title=\u003cmy-title\u003e}` is included, and code block titles are not\nenabled, no errors will occur, and the title attribute will be ignored.\n\n### HTML Favicons\nIf you would like to customize the favicons of your Quartz-based website, you \ncan add them to the `data/config.yaml` file. The **default** without any set \n`favicon` key is:\n\n```html {title=\"layouts/partials/head.html\", linenostart=15}\n\u003clink rel=\"shortcut icon\" href=\"icon.png\" type=\"image/png\"\u003e\n```\n\nThe default can be overridden by defining a value to the `favicon` key in your \n`data/config.yaml` file. For example, here is a `List[Dictionary]` example format, which is\nequivalent to the default:\n\n```yaml {title=\"data/config.yaml\", linenos=false}\nfavicon:\n  - { rel: \"shortcut icon\", href: \"icon.png\", type: \"image/png\" }\n#  - { ... } # Repeat for each additional favicon you want to add\n```\n\nIn this format, the keys are identical to their HTML representations.\n\nIf you plan to add multiple favicons generated by a website (see list below), it\nmay be easier to define it as HTML. Here is an example which appends the \n**Apple touch icon** to Quartz's default favicon:\n\n```yaml {title=\"data/config.yaml\", linenos=false}\nfavicon: |\n  \u003clink rel=\"shortcut icon\" href=\"icon.png\" type=\"image/png\"\u003e\n  \u003clink rel=\"apple-touch-icon\" sizes=\"180x180\" href=\"/apple-touch-icon.png\"\u003e\n```\n\nThis second favicon will now be used as a web page icon when someone adds your \nwebpage to the home screen of their Apple device. If you are interested in more \ninformation about the current and past standards of favicons, you can read \n[this article](https://www.emergeinteractive.com/insights/detail/the-essentials-of-favicons/).\n\n**Note** that all generated favicon paths, defined by the `href` \nattribute, are relative to the `static/` directory.\n\n### Graph View\nTo customize the Interactive Graph view, you can poke around `data/graphConfig.yaml`.\n\n```yaml {title=\"data/graphConfig.yaml\"}\n# if true, a Global Graph will be shown on home page with full width, no backlink.\n# A different set of Local Graphs will be shown on sub pages.\n# if false, Local Graph will be default on every page as usual\nenableGlobalGraph: false\n\n### Local Graph ###\nlocalGraph:\n    # whether automatically generate a legend\n    enableLegend: false\n    \n    # whether to allow dragging nodes in the graph\n    enableDrag: true\n    \n    # whether to allow zooming and panning the graph\n    enableZoom: true\n    \n    # how many neighbours of the current node to show (-1 is all nodes)\n    depth: 1\n    \n    # initial zoom factor of the graph\n    scale: 1.2\n    \n    # how strongly nodes should repel each other\n    repelForce: 2\n\n    # how strongly should nodes be attracted to the center of gravity\n    centerForce: 1\n\n    # what the default link length should be\n    linkDistance: 1\n    \n    # how big the node labels should be\n    fontSize: 0.6\n    \n    # scale at which to start fading the labes on nodes\n    opacityScale: 3\n\n### Global Graph ###\nglobalGraph:\n\t# same settings as above\n\n### For all graphs ###\n# colour specific nodes path off of their path\npaths:\n  - /moc: \"#4388cc\"\n```\n\n\n## Styling\nWant to go even more in-depth? You can add custom CSS styling and change existing colours through editing `assets/styles/custom.scss`. If you'd like to target specific parts of the site, you can add ids and classes to the HTML partials in `/layouts/partials`. \n\n### Partials\nPartials are what dictate what gets rendered to the page. Want to change how pages are styled and structured? You can edit the appropriate layout in `/layouts`.\n\nFor example, the structure of the home page can be edited through `/layouts/index.html`. To customize the footer, you can edit `/layouts/partials/footer.html`\n\nMore info about partials on [Hugo's website.](https://gohugo.io/templates/partials/)\n\nStill having problems? Checkout our [FAQ and Troubleshooting guide](notes/troubleshooting.md).\n\n## Language Support\n[CJK + Latex Support (ÊµãËØï)](notes/CJK%20+%20Latex%20Support%20(ÊµãËØï).md) comes out of the box with Quartz.\n\nWant to support languages that read from right-to-left (like Arabic)? Hugo (and by proxy, Quartz) supports this natively.\n\nFollow the steps [Hugo provides here](https://gohugo.io/content-management/multilingual/#configure-languages) and modify your `config.toml`\n\nFor example:\n\n```toml\ndefaultContentLanguage = 'ar'\n[languages]\n  [languages.ar]\n    languagedirection = 'rtl'\n    title = 'ŸÖÿØŸàŸÜÿ™Ÿä'\n    weight = 1\n```\n","lastmodified":"2022-10-19T15:09:54.746733418Z","tags":null},"/notes/custom-Domain":{"title":"Custom Domain","content":"\n### Registrar\nThis step is only applicable if you are using a **custom domain**! If you are using a `\u003cYOUR-USERNAME\u003e.github.io` domain, you can skip this step.\n\nFor this last bit to take effect, you also need to create a CNAME record with the DNS provider you register your domain with (i.e. NameCheap, Google Domains).\n\nGitHub has some [documentation on this](https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/managing-a-custom-domain-for-your-github-pages-site), but the tldr; is to\n\n1. Go to your forked repository (`github.com/\u003cYOUR-GITHUB-USERNAME\u003e/quartz`) settings page and go to the Pages tab. Under \"Custom domain\", type your custom domain, then click **Save**.\n2. Go to your DNS Provider and create a CNAME record that points from your domain to `\u003cYOUR-GITHUB-USERNAME.github.io.` (yes, with the trailing period).\n\n\t![Example Configuration for Quartz](/notes/images/google-domains.png)*Example Configuration for Quartz*\n3. Wait 30 minutes to an hour for the network changes to kick in.\n4. Done!","lastmodified":"2022-10-19T15:09:54.746733418Z","tags":null},"/notes/editing":{"title":"Editing Content in Quartz","content":"\n## Editing \nQuartz runs on top of [Hugo](https://gohugo.io/) so all notes are written in [Markdown](https://www.markdownguide.org/getting-started/).\n\n### Folder Structure\nHere's a rough overview of what's what.\n\n**All content in your garden can found in the `/content` folder.** To make edits, you can open any of the files and make changes directly and save it. You can organize content into any folder you'd like.\n\n**To edit the main home page, open `/content/_index.md`.**\n\nTo create a link between notes in your garden, just create a normal link using Markdown pointing to the document in question. Please note that **all links should be relative to the root `/content` path**. \n\n```markdown\nFor example, I want to link this current document to `notes/config.md`.\n[A link to the config page](notes/config.md)\n```\n\nSimilarly, you can put local images anywhere in the `/content` folder.\n\n```markdown\nExample image (source is in content/notes/images/example.png)\n![Example Image](/content/notes/images/example.png)\n```\n\nYou can also use wikilinks if that is what you are more comfortable with!\n\n### Front Matter\nHugo is picky when it comes to metadata for files. Make sure that your title is double-quoted and that you have a title defined at the top of your file like so. You can also add tags here as well.\n\n```yaml\n---\ntitle: \"Example Title\"\ntags:\n- example-tag\n---\n\nRest of your content here...\n```\n\n### Obsidian\nI recommend using [Obsidian](http://obsidian.md/) as a way to edit and grow your digital garden. It comes with a really nice editor and graphical interface to preview all of your local files.\n\nThis step is **highly recommended**.\n\n\u003e üîó Step 3: [How to setup your Obsidian Vault to work with Quartz](notes/obsidian.md)\n\n## Previewing Changes\nThis step is purely optional and mostly for those who want to see the published version of their digital garden locally before opening it up to the internet. This is *highly recommended* but not required.\n\n\u003e üëÄ Step 4: [Preview Quartz Changes](notes/preview%20changes.md)\n\nFor those who like to live life more on the edge, viewing the garden through Obsidian gets you pretty close to the real thing.\n\n## Publishing Changes\nNow that you know the basics of managing your digital garden using Quartz, you can publish it to the internet!\n\n\u003e üåç Step 5: [Hosting Quartz online!](notes/hosting.md)\n\nHaving problems? Checkout our [FAQ and Troubleshooting guide](notes/troubleshooting.md).\n","lastmodified":"2022-10-19T15:09:54.746733418Z","tags":null},"/notes/hosting":{"title":"Deploying Quartz to the Web","content":"\n## Hosting on GitHub Pages\nQuartz is designed to be effortless to deploy. If you forked and cloned Quartz directly from the repository, everything should already be good to go! Follow the steps below.\n\n### Enable GitHub Actions\nBy default, GitHub disables workflows from running automatically on Forked Repostories. Head to the 'Actions' tab of your forked repository and Enable Workflows to setup deploying your Quartz site!\n\n![Enable GitHub Actions](notes/images/github-actions.png)*Enable GitHub Actions*\n\n### Enable GitHub Pages\n\nHead to the 'Settings' tab of your forked repository and go to the 'Pages' tab.\n\n1. (IMPORTANT) Set the source to deploy from `master` (and not `hugo`) using `/ (root)`\n2. Set a custom domain here if you have one!\n\n![Enable GitHub Pages](/notes/images/github-pages.png)*Enable GitHub Pages*\n\n### Pushing Changes\nTo see your changes on the internet, we need to push it them to GitHub. Quartz is a `git` repository so updating it is the same workflow as you would follow as if it were just a regular software project.\n\n```shell\n# Navigate to Quartz folder\ncd \u003cpath-to-quartz\u003e\n\n# Commit all changes\ngit add .\ngit commit -m \"message describing changes\"\n\n# Push to GitHub to update site\ngit push origin hugo\n```\n\nNote: we specifically push to the `hugo` branch here. Our GitHub action automatically runs everytime a push to is detected to that branch and then updates the `master` branch for redeployment.\n\n### Setting up the Site\nNow let's get this site up and running. Never hosted a site before? No problem. Have a fancy custom domain you already own or want to subdomain your Quartz? That's easy too.\n\nHere, we take advantage of GitHub's free page hosting to deploy our site. Change `baseURL` in `/config.toml`. \n\nMake sure that your `baseURL` has a trailing `/`!\n\n[Reference `config.toml` here](https://github.com/jackyzha0/quartz/blob/hugo/config.toml)\n\n```toml\nbaseURL = \"https://\u003cYOUR-DOMAIN\u003e/\"\n```\n\nIf you are using this under a subdomain (e.g. `\u003cYOUR-GITHUB-USERNAME\u003e.github.io/quartz`), include the trailing `/`. **You need to do this especially if you are using GitHub!**\n\n```toml\nbaseURL = \"https://\u003cYOUR-GITHUB-USERNAME\u003e.github.io/quartz/\"\n```\n\nChange `cname` in `/.github/workflows/deploy.yaml`. Again, if you don't have a custom domain to use, you can use `\u003cYOUR-USERNAME\u003e.github.io`.\n\nPlease note that the `cname` field should *not* have any path `e.g. end with /quartz` or have a trailing `/`.\n\n[Reference `deploy.yaml` here](https://github.com/jackyzha0/quartz/blob/hugo/.github/workflows/deploy.yaml)\n\n```yaml {title=\".github/workflows/deploy.yaml\"}\n- name: Deploy  \n  uses: peaceiris/actions-gh-pages@v3  \n  with:  \n\tgithub_token: ${{ secrets.GITHUB_TOKEN }} # this can stay as is, GitHub fills this in for us!\n\tpublish_dir: ./public  \n\tpublish_branch: master\n\tcname: \u003cYOUR-DOMAIN\u003e\n```\n\nHave a custom domain? [Learn how to set it up with Quartz ](notes/custom%20Domain.md).\n\n### Ignoring Files\nOnly want to publish a subset of all of your notes? Don't worry, Quartz makes this a simple two-step process.\n\n‚ùå [Excluding pages from being published](notes/ignore%20notes.md)\n\n---\n\nNow that your Quartz is live, let's figure out how to make Quartz really *yours*!\n\n\u003e Step 6: üé® [Customizing Quartz](notes/config.md)\n\nHaving problems? Checkout our [FAQ and Troubleshooting guide](notes/troubleshooting.md).\n","lastmodified":"2022-10-19T15:09:54.746733418Z","tags":null},"/notes/ignore-notes":{"title":"Ignoring Notes","content":"\n### Quartz Ignore\nEdit `ignoreFiles` in `config.toml` to include paths you'd like to exclude from being rendered.\n\n```toml\n...\nignoreFiles = [  \n    \"/content/templates/*\",  \n    \"/content/private/*\", \n    \"\u003cyour path here\u003e\"\n]\n```\n\n`ignoreFiles` supports the use of Regular Expressions (RegEx) so you can ignore patterns as well (e.g. ignoring all `.png`s by doing `\\\\.png$`).\nTo ignore a specific file, you can also add the tag `draft: true` to the frontmatter of a note.\n\n```markdown\n---\ntitle: Some Private Note\ndraft: true\n---\n...\n```\n\nMore details in [Hugo's documentation](https://gohugo.io/getting-started/configuration/#ignore-content-and-data-files-when-rendering).\n\n### Global Ignore\nHowever, just adding to the `ignoreFiles` will only prevent the page from being access through Quartz. If you want to prevent the file from being pushed to GitHub (for example if you have a public repository), you need to also add the path to the `.gitignore` file at the root of the repository.","lastmodified":"2022-10-19T15:09:54.746733418Z","tags":null},"/notes/obsidian":{"title":"Obsidian Vault Integration","content":"\n## Setup\nObsidian is the preferred way to use Quartz. You can either create a new Obsidian Vault or link one that your already have.\n\n### New Vault\nIf you don't have an existing Vault, [download Obsidian](https://obsidian.md/) and create a new Vault in the `/content` folder that you created and cloned during the [setup](notes/setup.md) step.\n\n### Linking an existing Vault\nThe easiest way to use an existing Vault is to copy all of your files (directory and hierarchies intact) into the `/content` folder.\n\n## Settings\nGreat, now that you have your Obsidian linked to your Quartz, let's fix some settings so that they play well.\n\n1. Under Options \u003e Files and Links, set the New link format to always use Absolute Path in Vault.\n2. Go to Settings \u003e Files \u0026 Links \u003e Turn \"on\" automatically update internal links.\n\n![Obsidian Settings](/notes/images/obsidian-settings.png)*Obsidian Settings*\n\n## Templates\nInserting front matter everytime you want to create a new Note gets annoying really quickly. Luckily, Obsidian supports templates which makes inserting new content really easily.\n\n**If you decide to overwrite the `/content` folder completely, don't remove the `/content/templates` folder!**\n\nHead over to Options \u003e Core Plugins and enable the Templates plugin. Then go to Options \u003e Hotkeys and set a hotkey for 'Insert Template' (I recommend `[cmd]+T`). That way, when you create a new note, you can just press the hotkey for a new template and be ready to go!\n\n\u003e üëÄ Step 4: [Preview Quartz Changes](notes/preview%20changes.md)","lastmodified":"2022-10-19T15:09:54.750733136Z","tags":null},"/notes/philosophy":{"title":"Quartz Philosophy","content":"\n\u003e ‚Äú[One] who works with the door open gets all kinds of interruptions, but [they] also occasionally gets clues as to what the world is and what might be important.‚Äù ‚Äî Richard Hamming\n\n## Why Quartz?\nHosting a public digital garden isn't easy. There are an overwhelming number of tutorials, resources, and guides for tools like [Notion](https://www.notion.so/), [Roam](https://roamresearch.com/), and [Obsidian](https://obsidian.md/), yet none of them have super easy to use *free* tools to publish that garden to the world.\n\nI've personally found that\n1. It's nice to access notes from anywhere\n2. Having a public digital garden invites open conversations\n3. It makes keeping personal notes and knowledge *playful and fun*\n\nI was really inspired by [Bianca](https://garden.bianca.digital/) and [Joel](https://joelhooks.com/digital-garden)'s digital gardens and wanted to try making my own.\n\n**The goal of Quartz is to make hosting your own public digital garden free and simple.** You don't even need your own website. Quartz does all of that for you and gives your own little corner of the internet.\n","lastmodified":"2022-10-19T15:09:54.750733136Z","tags":null},"/notes/preview-changes":{"title":"Preview Changes","content":"\nIf you'd like to preview what your Quartz site looks like before deploying it to the internet, here's exactly how to do that!\n\nNote that both of these steps need to be completed.\n\n## Install `hugo-obsidian`\nThis step will generate the list of backlinks for Hugo to parse. Ensure you have [Go](https://golang.org/doc/install) (\u003e= 1.16) installed.\n\n```bash\n# Install and link `hugo-obsidian` locally\ngo install github.com/jackyzha0/hugo-obsidian@latest\n```\n\nIf you are running into an error saying that `command not found: hugo-obsidian`, make sure you set your `GOPATH` correctly! This will allow your terminal to correctly recognize hugo-obsidian as an executable.\n\nAfterwards, start the Hugo server as shown above and your local backlinks and interactive graph should be populated!\n\n##  Installing Hugo\nHugo is the static site generator that powers Quartz. [Install Hugo with \"extended\" Sass/SCSS version](https://gohugo.io/getting-started/installing/) first. Then,\n\n```bash\n# Navigate to your local Quartz folder\ncd \u003clocation-of-your-local-quartz\u003e\n\n# Start local server\nmake serve\n\n# View your site in a browser at http://localhost:1313/\n```\n\n\u003e üåç Step 5: [Hosting Quartz online!](notes/hosting.md)","lastmodified":"2022-10-19T15:09:54.750733136Z","tags":null},"/notes/search":{"title":"Search","content":"\nQuartz supports two modes of searching through content.\n\n## Full-text\nFull-text search is the default in Quartz. It produces results that *exactly* match the search query. This is easier to setup but usually produces lower quality matches.\n\n```yaml {title=\"data/config.yaml\"}\n# the default option\nenableSemanticSearch: false\n```\n\n## Natural Language\nNatural language search is powered by [Operand](https://operand.ai/). It understands language like a person does and finds results that best match user intent. In this sense, it is closer to how Google Search works.\n\nNatural language search tends to produce higher quality results than full-text search.\n\nHere's how to set it up.\n\n1. Create an Operand Account on [their website](https://operand.ai/).\n2. Go to Dashboard \u003e Settings \u003e Integrations.\n3. Follow the steps to setup the GitHub integration. Operand needs access to GitHub in order to index your digital garden properly!\n4. Head over to Dashboard \u003e Objects and press `(Cmd + K)` to open the omnibar and select 'Create Collection'.\n\t1. Set the 'Collection Label' to something that will help you remember it.\n\t2. You can leave the 'Parent Collection' field empty.\n5. Click into your newly made Collection.\n\t1. Press the 'share' button that looks like three dots connected by lines.\n\t2. Set the 'Interface Type' to `object-search` and click 'Create'.\n\t3. This will bring you to a new page with a search bar. Ignore this for now.\n6. Go back to Dashboard \u003e Settings \u003e API Keys and find your Quartz-specific Operand API key under 'Other keys'.\n\t1. Copy the key (which looks something like `0e733a7f-9b9c-48c6-9691-b54fa1c8b910`).\n\t2. Open `data/config.yaml`. Set `enableSemanticSearch` to `true` and `operandApiKey` to your copied key.\n\n```yaml {title=\"data/config.yaml\"}\n# the default option\nenableSemanticSearch: true\noperandApiKey: \"0e733a7f-9b9c-48c6-9691-b54fa1c8b910\"\n```\n7. Make a commit and push your changes to GitHub. See the [[notes/hosting|hosting]] page if you haven't done this already.\n\t1. This step is *required* for Operand to be able to properly index your content. \n\t2. Head over to Dashboard \u003e Objects and select the collection that you made earlier\n8. Press `(Cmd + K)` to open the omnibar again and select 'Create GitHub Repo'\n\t1. Set the 'Repository Label' to `Quartz`\n\t2. Set the 'Repository Owner' to your GitHub username\n\t3. Set the 'Repository Ref' to `master`\n\t4. Set the 'Repository Name' to the name of your repository (usually just `quartz` if you forked the repository without changing the name)\n\t5. Leave 'Root Path' and 'Root URL' empty\n9. Wait for your repository to index and enjoy natural language search in Quartz! Operand refreshes the index every 2h so all you need to do is just push to GitHub to update the contents in the search.","lastmodified":"2022-10-19T15:09:54.750733136Z","tags":null},"/notes/setup":{"title":"Setup","content":"\n## Making your own Quartz\nSetting up Quartz requires a basic understanding of `git`. If you are unfamiliar, [this resource](https://resources.nwplus.io/2-beginner/how-to-git-github.html) is a great place to start!\n\n### Forking\n\u003e A fork is a copy of a repository. Forking a repository allows you to freely experiment with changes without affecting the original project.\n\nNavigate to the GitHub repository for the Quartz project:\n\nüìÅ [Quartz Repository](https://github.com/jackyzha0/quartz)\n\nThen, Fork the repository into your own GitHub account. If you don't have an account, you can make on for free [here](https://github.com/join). More details about forking a repo can be found on [GitHub's documentation](https://docs.github.com/en/get-started/quickstart/fork-a-repo).\n\n### Cloning\nAfter you've made a fork of the repository, you need to download the files locally onto your machine. Ensure you have `git`, then type the following command replacing `YOUR-USERNAME` with your GitHub username.\n\n```shell\ngit clone https://github.com/YOUR-USERNAME/quartz\n```\n\n## Editing\nGreat! Now you have everything you need to start editing and growing your digital garden. If you're ready to start writing content already, check out the recommended flow for editing notes in Quartz.\n\n\u003e ‚úèÔ∏è Step 2: [Editing Notes in Quartz](notes/editing.md)\n\nHaving problems? Checkout our [FAQ and Troubleshooting guide](notes/troubleshooting.md).\n","lastmodified":"2022-10-19T15:09:54.750733136Z","tags":null},"/notes/showcase":{"title":"Showcase","content":"\nWant to see what Quartz can do? Here are some cool community gardens :)\n\n- [Quartz Documentation (this site!)](https://quartz.jzhao.xyz/)\n- [Jacky Zhao's Garden](https://jzhao.xyz/)\n- [Scaling Synthesis - A hypertext research notebook](https://scalingsynthesis.com/)\n- [AWAGMI Intern Notes](https://notes.awagmi.xyz/)\n- [Shihyu's PKM](https://shihyuho.github.io/pkm/)\n- [Chloe's Garden](https://garden.chloeabrasada.online/)\n- [SlRvb's Site](https://slrvb.github.io/Site/)\n- [Course notes for Information Technology Advanced Theory](https://a2itnotes.github.io/quartz/)\n- [Brandon Boswell's Garden](https://brandonkboswell.com)\n- [Siyang's Courtyard](https://siyangsun.github.io/courtyard/)\n\nIf you want to see your own on here, submit a [Pull Request adding yourself to this file](https://github.com/jackyzha0/quartz/blob/hugo/content/notes/showcase.md)!\n","lastmodified":"2022-10-19T15:09:54.750733136Z","tags":null},"/notes/troubleshooting":{"title":"Troubleshooting and FAQ","content":"\nStill having trouble? Here are a list of common questions and problems people encounter when installing Quartz.\n\nWhile you're here, join our [Discord](https://discord.gg/cRFFHYye7t) :)\n\n### Does Quartz have Latex support?\nYes! See [CJK + Latex Support (ÊµãËØï)](notes/CJK%20+%20Latex%20Support%20(ÊµãËØï).md) for a brief demo.\n\n### Can I use \\\u003cObsidian Plugin\\\u003e in Quartz?\nUnless it produces direct Markdown output in the file, no. There currently is no way to bundle plugin code with Quartz.\n\nThe easiest way would be to add your own HTML partial that supports the functionality you are looking for.\n\n### My GitHub pages is just showing the README and not Quartz\nMake sure you set the source to deploy from `master` (and not `hugo`) using `/ (root)`! See more in the [hosting](/notes/hosting) guide\n\n### Some of my pages have 'January 1, 0001' as the last modified date\nThis is a problem caused by `git` treating files as case-insensitive by default and some of your posts probably have capitalized file names. You can turn this off in your Quartz by running this command.\n\n```shell\n# in the root of your Quartz (same folder as config.toml)\ngit config core.ignorecase true\n\n# or globally (not recommended)\ngit config --global core.ignorecase true\n```\n\n### Can I publish only a subset of my pages?\nYes! Quartz makes selective publishing really easy. Heres a guide on [excluding pages from being published](notes/ignore%20notes.md).\n\n### Can I host this myself and not on GitHub Pages?\nYes! All built files can be found under `/public` in the `master` branch. More details under [hosting](notes/hosting.md).\n\n### `command not found: hugo-obsidian`\nMake sure you set your `GOPATH` correctly! This will allow your terminal to correctly recognize `hugo-obsidian` as an executable.\n\n```shell\n# Add the following 2 lines to your ~/.bash_profile\nexport GOPATH=/Users/$USER/go\nexport PATH=$GOPATH/bin:$PATH\n\n# In your current terminal, to reload the session\nsource ~/.bash_profile\n```\n\n### How come my notes aren't being rendered?\nYou probably forgot to include front matter in your Markdown files. You can either setup [Obsidian](notes/obsidian.md) to do this for you or you need to manually define it. More details in [the 'how to edit' guide](notes/editing.md).\n\n### My custom domain isn't working!\nWalk through the steps in [the hosting guide](notes/hosting.md) again. Make sure you wait 30 min to 1 hour for changes to take effect.\n\n### How do I setup Google Analytics?\nYou can edit it in `config.toml` and either use a V3 (UA-) or V4 (G-) tag.\n\n### How do I change the content on the home page?\nTo edit the main home page, open `/content/_index.md`.\n\n### How do I change the colours?\nYou can change the theme by editing `assets/custom.scss`. More details on customization and themeing can be found in the [customization guide](notes/config.md).\n\n### How do I add images?\nYou can put images anywhere in the `/content` folder.\n\n```markdown\nExample image (source is in content/notes/images/example.png)\n![Example Image](/content/notes/images/example.png)\n```\n\n### My Interactive Graph and Backlinks aren't up to date\nBy default, the `linkIndex.json` (which Quartz needs to generate the Interactive Graph and Backlinks) are not regenerated locally. To set that up, see the guide on [local editing](notes/editing.md)\n\n### Can I use React/Vue/some other framework?\nNot out of the box. You could probably make it work by editing `/layouts/_default/single.html` but that's not what Quartz is designed to work with. 99% of things you are trying to do with those frameworks you can accomplish perfectly fine using just vanilla HTML/CSS/JS.\n\n## Still Stuck?\nQuartz isn't perfect! If you're still having troubles, file an issue in the GitHub repo with as much information as you can reasonably provide. Alternatively, you can message me on [Twitter](https://twitter.com/_jzhao) and I'll try to get back to you as soon as I can.\n\nüêõ [Submit an Issue](https://github.com/jackyzha0/quartz/issues)","lastmodified":"2022-10-19T15:09:54.750733136Z","tags":null},"/notes/updating":{"title":"Updating","content":"\nHaven't updated Quartz in a while and want all the cool new optimizations? On Unix/Mac systems you can run the following command for a one-line update! This command will show you a log summary of all commits since you last updated, press `q` to acknowledge this. Then, it will show you each change in turn and press `y` to accept the patch or `n` to reject it. Usually you should press `y` for most of these unless it conflicts with existing changes you've made! \n\n```shell\nmake update\n```\n\nOr, if you don't want the interactive parts and just want to force update your local garden (this assumed that you are okay with some of your personalizations been overriden!)\n\n```shell\nmake update-force\n```\n\nOr, manually checkout the changes yourself.\n\n\u003e [!warning] Warning!\n\u003e\n\u003e If you customized the files in `data/`, or anything inside `layouts/`, your customization may be overwritten!\n\u003e Make sure you have a copy of these changes if you don't want to lose them.\n\n\n```shell\n# add Quartz as a remote host\ngit remote add upstream git@github.com:jackyzha0/quartz.git\n\n# index and fetch changes\ngit fetch upstream\ngit checkout -p upstream/hugo -- layouts .github Makefile assets/js assets/styles/base.scss assets/styles/darkmode.scss config.toml data \n```\n","lastmodified":"2022-10-19T15:09:54.750733136Z","tags":null},"/vault/Otimiza%C3%A7%C3%A3o/Branch-and-cut":{"title":"Branch-and-cut","content":"","lastmodified":"2022-10-19T15:09:54.834727215Z","tags":null},"/vault/Otimiza%C3%A7%C3%A3o/Enumera%C3%A7%C3%A3o-impl%C3%ADcita-de-solu%C3%A7%C3%B5es":{"title":"Enumera√ß√£o impl√≠cita","content":"\n# A estrat√©gia de [[Branch-and-bound]]\n\nA estrat√©gia de [[vault/Otimiza√ß√£o/Enumera√ß√£o impl√≠cita de solu√ß√µes|Branch-and-bound]] foi proposta originalmente em 1960 por [[Ailsa Land]] e [[Alison Doig]] como m√©todo para solu√ß√£o de problemas discretos de otimiza√ß√£o. Trata-se de uma forma de enumerar implicitamente as solu√ß√µes vi√°veis de um problema.\n\nJuntamente com [[Algoritmos de planos de corte]] constituem o framework [[Branch-and-cut]], base de diversos pacotes computacionais para problemas de [[Otimiza√ß√£o Inteira]].\n\nPara exemplificar a estrat√©gia do [[vault/Otimiza√ß√£o/Enumera√ß√£o impl√≠cita de solu√ß√µes|branch-and-bound]] vamos utilizar o [[Problema do Caixeiro Viajante]].\n\n# O [[Problema do Caixeiro Viajante]]\n\nUm vendedor deseja visitar as cidades $1, 2, \\ldots, N-1$, partindo da sede de uma empresa na cidade $0$. O custo de viajar de uma cidade $i$ para uma cidade $j$ √© $c_{ij}$, $i, j = 0, 1, \\ldots, N-1$. O problema de determinar uma rota com o menor custo que visita todas as cidades exatamente uma vez √© conhecido como [[Problema do Caixeiro Viajante]].\n\n## Uma solu√ß√£o com enumera√ß√£o expl√≠cita\n\nSolu√ß√£o baseada na permuta√ß√£o da lista de cidades $(0, 1, 2, \\ldots, N-1)$. √â poss√≠vel encontrar uma solu√ß√£o gerando todas as permuta√ß√µes da lista de cidades.\n\nPor exemplo, se $N = 4$ basta avaliar todas as sequ√™ncias $(N-1)! = 6$  sequ√™ncias e escolher a de menor custo.\n1.  $(0, 1, 2, 3)$\t\n2.  $(0, 1, 3, 2)$\n3.  $(0, 2, 1, 3)$\n4.  $(0, 2, 3, 1)$\n5.  $(0, 3, 1, 2)$\n6.  $(0, 3, 2, 1)$\n\nA rela√ß√£o de recorr√™ncia para gerar as permuta√ß√µes de uma sequ√™ncia $S = (0, 1, \\ldots, N-1)$ de tamanho $N$ √© dada por \n\n$$S_N = \\bigcup_{i \\notin S_{N-1}}\\langle S_{N-1} | i\\rangle$$\n### Implementa√ß√£o utilizando [[Backtracking]]\n\nPode-se realizar uma numera√ß√£o expl√≠cita da todas as permuta√ß√µes da sequ√™ncia $S = (0, 1, \\ldots, N-1)$, computar o custo de cada uma delas, identificando, assim uma solu√ß√£o √≥tima. Para isso, pode-se utilizar o c√≥digo a seguir.\n\n```python\ndef backtrack(sol, left, N, best=INFINITY, opt=None):\n    if left == N:\n        cost = sol.get_value()\n        if cost \u003c best:\n            best = cost\n            opt = deepcopy(sol)\n    else:\n\t\tfor i in range(left, N):\n\t\t\tsol.tour[left], sol.tour[i] = sol.tour[i], sol.tour[left]           \n\t\t\tbest, opt = backtrack(sol, left+1, N, best, opt)\n\t\t\tsol.tour[left], sol.tour[i] = sol.tour[i], sol.tour[left]\n    return best, opt\n```\n\n### Alguns testes\n\nForam gerados $N$ pontos aleat√≥rios em uma √°rea 100 x 100. O tempo computacional para se encontrar uma solu√ß√£o √≥tima do [[Problema do Caixeiro Viajante]] para esses pontos √© apresentado na tabela a seguir, para diferentes valores de $N$.\n\n| $N$   | Tempo (s) |\n| --- | --------- |\n| 5   | 0.001     |\n| 6   | 0.003     |\n| 7   | 0.006     |\n| 8   | 0.030     |\n| 9   | 0.213     |\n| 10  | 1.999     |\n| 11  | 21.636    |\n| 12  | 312.102   |\n\n### An√°lise do algoritmo\n\nO algoritmo enumera todas as $(N-1)!$ solu√ß√µes vi√°veis para o problema e compara o custo da solu√ß√£o atual com a melhor encontrada at√© o momento. Portanto, o tempo computacional do algoritmo √© de complexidade $O(N!)$.\n\nMelhorar as configura√ß√µes de hardware ou utilizar uma linguagem como C/C++ poderia aumentar o tamanho dos problemas resolvidos no mesmo tempo computacional?\n\n#### Em um mundo mais r√°pido\n\nConforme o n√∫mero de cidades $N$ aumenta, o n√∫mero de solu√ß√µes tamb√©m aumenta\n\n| $N$     | Tempo (s)            |\n| ----- | -------------------- |\n| $5$   | $24$                 |\n| $10$  | $362880$             |\n| $20$  | $1\\,2 \\cdot 10^{17}$ |\n| $100$ | $\\approx 10^{156}$   |\n\nConsiderando um computador que consiga avaliar (computar o custo) de uma solu√ß√£o em $10^{-34}s$, seriam necess√°rios $$\\approx 10^{122}s.$$ Mas a idade do universo √© da ordem de $10^{17}s$ (e contando...).\n\n\u003e A [Constante de Planck](https://en.wikipedia.org/wiki/Planck_constant) foi a menor constante f√≠sica que eu consegui encontrar e tem valor da ordem de $10^{-34}$, expresso em unidades do Sistema Internacional.\n\nPortanto, uma solu√ß√£o √© investir em algoritmo que evitem enumerar todas as solu√ß√µes explicitamente. \n\n## Uma enumera√ß√£o √≠mplicita\n\nNa verdade, n√£o √© necess√°rio explorar todas as solu√ß√µes explicitamente. Note que o algoritmo proposto adiciona uma cidade a cada chamada da fun√ß√£o, ou seja, em qualquer chamada da fun√ß√£o em que a condi√ß√£o $left == N$ n√£o √© verdadeira, existe uma solu√ß√£o parcial definida $p = (a_0, a_1, a_2, \\ldots, a_i), i \u003c N-1$. √â poss√≠vel calcular o custo de uma solu√ß√£o parcial $$c(p) = \\sum_{j=0}^{i-1} c_{j, j+1}.$$\nSe a solu√ß√£o parcial $p$ tiver um custo, $c(p)$, maior ou igual ao da melhor solu√ß√£o completa encontrada at√© o momento, n√£o √© necess√°rio continuar explorando o ramo atual da √°rvore.  Por qu√™? Com essa modifica√ß√£o, h√° garantia de que uma solu√ß√£o √≥tima ser√° encontrada? \n\nEssa estrat√©gia de poda da √°rvore √© conhecida como poda por qualidade. \n\n### Implementa√ß√£o com poda por qualidade\n\n```python\ndef backtrack(sol, left, N, best=INFINITY, opt=None):\n    if left == N:\n        cost = sol.get_value()\n        if cost \u003c best:\n            best = cost\n            opt = deepcopy(sol)\n    else:\n        cur_value = sol.get_value(0, left)\n        if cur_value \u003c best:\n            for i in range(left, N):\n                sol.tour[left], sol.tour[i] = sol.tour[i], sol.tour[left]           \n                best, opt = backtrack(sol, left+1, N, best, opt)\n                sol.tour[left], sol.tour[i] = sol.tour[i], sol.tour[left]\n    return best, opt\n```\n\nCom a poda por qualidade baseada no custo das solu√ß√µes parciais √© poss√≠vel resolver problemas de dimens√µes maiores em tempo computacional similar.\n\n| $N$   | Tempo (s) |\n| --- | --------- |\n| 5   | 0.002     |\n| 6   | 0.003     |\n| 7   | 0.005     |\n| 8   | 0.009     |\n| 9   | 0.029     |\n| 10  | 0.097     |\n| 11  | 0.843     |\n| 12  | 4.303     |\n| 13  | 24.263    |\n| 14  | 61.984    |\n| 15  | 325.719   |\n\n\n### [[vault/Otimiza√ß√£o/Enumera√ß√£o impl√≠cita de solu√ß√µes]], utilizando um [[limitante inferior]]\n\n√â poss√≠vel utilizar uma poda que inclui informa√ß√µes otimistas sobre o custo a ser atingido caso se continue explorando determinado ramo da √°rvore.  Uma op√ß√£o √© utilizar a [[Problema da √Årvore Geradora M√≠nima|√Årvore Geradora M√≠nima]] dos n√≥s que ainda n√£o foram visitados pela solu√ß√£o parcial atual. \n\nNote que o custo de uma [[Problema da √Årvore Geradora M√≠nima|√Årvore Geradora M√≠nima]] considerando os $N$ n√≥s √© um limitante inferior (otimista) para o custo de uma solu√ß√£o do [[Problema do Caixeiro Viajante]] com os mesmo $N$ n√≥s. \n\n- Seja $t$ um tour no grafo $G$. A remo√ß√£o de uma aresta de $G$ produz um caminho $r$. Como os custos das arestas s√£o n√£o negativos, tem-se $c(r) \\leq c(t)$. Como um caminho √© tamb√©m uma √°rvore, tem-se que o custo da √Årvore Geradora M√≠nima (MST) √© tal que $$c(MST) \\leq c(r) \\leq c(t).$$\n\nIsso possibilita que a opera√ß√£o de poda inclua informa√ß√µes sobre a solu√ß√£o de um [[Problema da √Årvore Geradora M√≠nima]] para eliminar ramos da √°rvore que n√£o forne√ßam solu√ß√µes melhores do que a atual. \n\n\u003e Seja $z$ o valor da melhor solu√ß√£o conhecida at√© o momento, $P = (a_0, a_1, \\ldots, a_i), i \u003c N,$ a solu√ß√£o parcial para o [[Problema do Caixeiro Viajante]] e $T$ uma [[Problema da √Årvore Geradora M√≠nima|√Årvore Geradora M√≠nima]] contemplando todos os n√≥s n√£o visitados na solu√ß√£o atual, $j \\notin P$. Ent√£o,  se $c(P) + c(T) \\geq z$ pode-se podar o ramo atual da √°rvore (n√£o √© necess√°rio explorar a solu√ß√£o parcial $P$).  Por qu√™? #pergunta\n\nPara utilizar o limitante baseado na [[Problema da √Årvore Geradora M√≠nima|√Årvore Geradora M√≠nima]] pode-se modificar a implementa√ß√£o como feito a seguir. \n\n```python\ndef backtrack(sol, left, N, best=INFINITY, opt=None):\n    if left == N:\n        cost = sol.get_value()\n        if cost \u003c best:\n            best = cost\n            opt = deepcopy(sol)\n    else:\n        cur_value = sol.get_value(0, left)\n        bound_value = get_mst_cost(sol.tour[left+1:], sol.dist)\n        if cur_value + bound_value \u003c best:\n            for i in range(left, N):\n                sol.tour[left], sol.tour[i] = sol.tour[i], sol.tour[left]           \n                best, opt = backtrack(sol, left+1, N, best, opt)\n                sol.tour[left], sol.tour[i] = sol.tour[i], sol.tour[left]\n    return best, opt\n```\n\nCom isso, executando algumas inst√¢ncias, obteve-se o seguinte resultado\n\n| N   | Tempo (s) |\n| --- | --------- |\n| 5   | 0.005     |\n| 6   | 0.007     |\n| 7   | 0.014     |\n| 8   | 0.021     |\n| 9   | 0.047     |\n| 10  | 0.095     |\n| 11  | 0.436     |\n| 12  | 0.854     |\n| 13  | 2.339     |\n| 14  | 4.523     |\n| 15  | 6.849     |\n| 16  | 13.905    |\n| 17  | 24.966    |\n| 18  | 31.602    |\n| 19  | 34.846    |\n| 20  | 121.833   |\n| 21  | 238.015   |\n| 22  | 367.061   |\n\n\nQuando se tem uma estrat√©gia para conseguir um limitante otimista (inferior no caso de problemas de minimiza√ß√£o e superior no caso de problemas de minimiza√ß√£o), pode-se desenvolver um algoritmo de [[vault/Otimiza√ß√£o/Enumera√ß√£o impl√≠cita de solu√ß√µes|Branch-and-bound]]. \n\n## Algumas conclus√µes\n\n- Para resolver esse problema (e outros NP-dif√≠ceis) √© necess√°rio lidar com o crescimento exponencial do espa√ßo de solu√ß√µes. \n- O que fazer a cada novo problema encontrado?\n\t- Criar um algoritmo de enumera√ß√£o expl√≠cita \n\t- Encontrar propriedades que permitam a poda\n\t\t- Poda por qualidade\n\t\t- Poda por infactibilidade\n\t- Encontrar problemas auxiliares que forne√ßam bons limitantes inferiores\n- Existe um arcabou√ßo que j√° possui todas essas \"funcionalidades\". Inclusive com pacotes computacionais com toda a ideia de [[vault/Otimiza√ß√£o/Enumera√ß√£o impl√≠cita de solu√ß√µes]] (e diversas outras) j√° implementada, sendo necess√°rio, apenas, fornecer os dados de entrada. Para aprendermos a utilizar tais ferramentas, precisamos aprender [[Programa√ß√£o Linear Inteira Mista]].\n\n# Refer√™ncias\n\n- [Land, Ailsa H., and Alison G. Doig. An automatic method for solving discrete programming problems. Econometrica\nVol. 28, No. 3 (Jul., 1960), pp. 497-520. ](https://link.springer.com/chapter/10.1007/978-3-540-68279-0_5)\n- Palestra [Tuning a TSP Algorithm](https://youtu.be/SS5KfIFzfEE). ","lastmodified":"2022-10-19T15:09:54.834727215Z","tags":null},"/vault/Otimiza%C3%A7%C3%A3o/Enumerando-solu%C3%A7%C3%B5es-explicitamente":{"title":"Enumera√ß√£o de solu√ß√µes","content":"\n\n- Algoritmo para enumera√ß√£o de subconjuntos\n- Algoritmo para enumera√ß√£o de permuta√ß√µes\n- Algoritmo para enumera√ß√£o de subsequ√™ncias","lastmodified":"2022-10-19T15:09:54.834727215Z","tags":null},"/vault/Otimiza%C3%A7%C3%A3o/Modelagem-para-programas-lineares-inteiros":{"title":"Modelagem para programas lineares inteiros","content":"\n\n# Programas Lineares Inteiros Mistos\n\n$$\\min c^Tx + h^Ty$$\n\nsujeito a\n\n$$Ax + Gy \\leq b,$$\n$$x \\in \\mathbb{Z}^n_+,$$\n$$y^p \\geq 0.$$\n\nOnde os par√¢metros s√£o valores racionais:\n- $c^T = (c_1, \\ldots, c_n)$ ,\n- $h^T = (h_1, \\ldots, h_n)$,\n- $A = (a_{ij})$ √© uma matrix $m \\times n$,\n- $G = (g_{ij})$ √© uma matrix $m \\times p$,\n- $b = (b_1, \\ldots, b_m)^T$.\n\nE as vari√°veis:\n- $x = (x_1, \\ldots, x_n)^T$, $n$ vari√°veis inteiras,\n- $y = (y_1, \\ldots, y_p)^T$, $p$ vari√°veis cont√≠nuas.\n\nPara um problema de Programa√ß√£o Linear Inteira Mista, par√¢metros s√£o valores racionais determin√≠sticos definidos antecipadamente. As vari√°veis representam decis√µes que podem ser tomadas. Cada atribui√ß√£o de valores para as vari√°veis √© chamado de **solu√ß√£o**. Uma solu√ß√£o pode ser:\n\n\u003e Solu√ß√£o vi√°vel (ou fact√≠vel). Atende todas as restri√ß√µes do problema.\n\n\u003e Solu√ß√£o invi√°vel (ou infact√≠vel). Deixa de atender pelo menos uma restri√ß√£o do problema.\n\n## Um primeiro exemplo: O [[Problema da mochila]]\n\n### O [[Problema da mochila]]\n\n\u003e No Problema da mochila, h√° uma mochila com capacidade $C$ e $n$ tipos de items, cada tipo item $i \\in \\{1, \\ldots, n\\}$ possui um peso e um valor $w_i$ e um valor, respectivamente. Qual √© a quantidade de cada tipo de item que deve ser colocada na mochila de forma a maximizar o valore carregado, sem ultrapassar a capacidade da mochila?\n\nPara elaborar um modelo √© necess√°rio definir quais s√£o as vari√°veis do problema. Uma primeira tentativa √© observar quais s√£o as decis√µes a serem tomadas. Nesse caso, isso √© suficiente para definir as vari√°veis:\n\n- $x_i \\in \\mathbb{Z}‚Å∫$: A quantidade de itens do tipo $i \\in \\{1, \\ldots, n\\}$ a serem carregadas na mochila. \n\nPara a constru√ß√£o do modelo √© necess√°rio escrever duas informa√ß√µes utilizando as vari√°veis e os par√¢metros do problema: \n- O peso do conjunto de itens escolhidos.\n\t- Note que a express√£o $w_1 x_1$ define o peso total dos itens de tipo $1$ escolhidos. Portanto\n\t- A express√£o $w_1 x_1 + w_2x_2 + \\ldots + w_nx_n$ compute o peso total dos itens escolhidos. A express√£o pode ser escrita concisamente como $$\\sum_{i=1}^nw_ix_i$$\n- O valor do conjunto de itens escolhidos.\n\t- Com um racic√≠nio an√°logo ao feito para o peso dos itens, tem-se: $$\\sum_{i=1}^nv_ix_i$$\n\nCom isso, a fun√ß√£o objetivo do problema pode ser escrita como $$\\max \\sum_{i=1}^n v_ix_i$$ sujeito as restri√ß√µes $$\\sum_{i=1}^nw_ix_i \\leq C,$$ $$x \\in \\mathbb{Z}^+.$$\n\nExemplos de implementa√ß√µes podem ser visto [[Problema da mochila#^091f1b]].\n\n## Artif√≠cios de modelagem\n\n### Modelando rela√ß√µes l√≥gicas com vari√°veis\n\nConsidere uma situa√ß√£o em que h√° um conjunto $S$ e a cada item do conjunto est√° associada uma vari√°vel bin√°ria $x_i, i \\in S$. Semelhante ao [[Problema da mochila]]. Algumas situa√ß√µes frequentes em modelagem s√£o exemplificadas a seguir.\n\n#### No m√°ximo $N$ elementos\n\nCaso seja necess√°rio que no m√°ximo $N$ elementos do conjunto sejam selecionados:\n\n$$\\sum_{i \\in S} x_i \\leq N.$$\n\n#### Pelo menos $N$ elementos\n\nCaso seja necess√°rio que no m√°ximo $N$ elementos do conjunto sejam selecionados:\n\n$$\\sum_{i \\in S} x_i \\geq N.$$\n\n#### Exatamente $N$ elementos\n\nCaso seja necess√°rio que exatamente $N$ elementos do conjunto sejam selecionados:\n\n$$\\sum_{i \\in S} x_i = N.$$\n\nEssa situa√ß√£o √© an√°loga a um ou-exclusivo entre duas vari√°veis  $x_1 + x_2 = 1$\n\n#### Se ... ent√£o... ($a \\Rightarrow b$)\n\nConsidere duas vari√°veis bin√°rias $x_a, x_b \\in \\{0, 1\\}$ e que se deseja modelar a situa√ß√£o em que $x_a = 1 \\Rightarrow x_b = 1$. Por exemplo, h√° situa√ß√µes em que a escolha de um item do conjunto implica na escolha de outro (do mesmo ou de outro conjunto). Isto √©, se $x_a = 1$ ent√£o $x_b = 1$, $a, b \\in S$.\n\n$$x_a \\leq x_b.$$\n\n- Considerando $x_a, x_b \\in \\{0, 1\\}$. Como modelar as seguintes situa√ß√µes? #pergunta \n\t- $x_a = 0 \\Rightarrow x_b = 0$\n\t- $x_a = 1 \\Rightarrow x_b = 0$\n\t- $x_a = 0 \\Rightarrow x_b = 1$\n\t- $x_a = 0 \\Leftrightarrow x_b = 0$\n\t\n\nOutra situa√ß√£o frequente √© envolvendo uma vari√°vel bin√°ria $x_a \\in \\{0, 1\\}$, um valor $L \\geq 0$ e uma vari√°vel continua $y \\geq 0$, tal que $$x_a = 1 \\Rightarrow y \\geq L.$$  Para modelar tal situa√ß√£o √© poss√≠vel utilizar a restri√ß√£o $$L x_a \\leq y.$$ Um racioc√≠nio similar √© utilizado no [[Problema de bin packing]].\n\n#### Um exemplo\n\nUma empresa est√° considerando expandir suas opera√ß√µes para dois novos estados $A$ e $B$. Tamb√©m, est√° considerando construir no m√°ximo um novo dep√≥sito, mas a localiza√ß√£o do dep√≥sito √© restrita √† localiza√ß√£o da nova f√°brica. O capital dispon√≠vel √© de 10 milh√µes. Os demais valores relacionados a tais escolhas √© apresentado a seguir.\n\nPara modelar o problema com o paradigma de Programa√ß√£o Inteira, considere as vari√°veis bin√°rias\n\n$$x_j = \\begin{cases}1 \\quad \\text{em caso afirmativo},\\\\ 0\\quad \\text{em caso negativo},\\end{cases}\\quad (j = 1, 2, 3, 4).$$\n\n| Decis√£o                    | Vari√°vel | Retorno previsto (R\\$) | Investimento necess√°rio (R\\$)| \n| -------------------------- | ------------------- | ---------------- | ----------------------- |\n| Construir f√°brica em $A$?  | $x_1$             |     9 milh√µes             | 6 milh√µes                        |\n| Construir f√°brica em $B$?  | $x_2$         |     5 milh√µes             | 3 milh√µes                        |\n| Construir dep√≥sito em $A$? | $x_3$         |   6 milh√µes               | 5 milh√µes                        |\n| Construir dep√≥sito em $B$? | $x_4$     |    4 milh√µes              | 2 milh√µes                        |\n\n- Seja $Z$ o retorno previsto por cada decis√£o. O retorno total em milh√µes de d√≥lares.\n\t-\t$$Z = 9x_1 + 5x_2 + 6x_3 + 4x_4.$$\n- Como o capital dispon√≠vel √© de 10 milh√µes, uma restri√ß√£o do modelo √© \n\t- $$6x_1 + 3x_2 + 5x_3 + 2x_4 \\leq 10.$$\n- No m√°ximo um dep√≥sito ser√° constru√≠do:\n\t- $$x_3 + x_4 \\leq 1.$$\n- Dep√≥sitos s√£o s√≥ constru√≠dos se uma f√°brica tamb√©m for.\n\t- $$x_3 \\leq x_1.$$\n\t- $$x_4 \\leq x_2.$$\n\nO modelo completo √© dado por:\n\n$$\\max Z = 9x_1 + 5x_2 + 6x_3 + 4x_4$$\n \n sujeito a\n\n$$6x_1 + 3x_2 + 5x_3 + 2x_4 \\leq 10.$$\n$$x_3 + x_4 \\leq 1.$$\n$$x_3 \\leq x_1.$$\n$$x_4 \\leq x_2.$$\n$$x_j \\in \\{0, 1\\} \\quad j = 1, 2, 3, 4$$\n\n\nEste exemplo foi adaptado de [[2014Hillier_IntroductionToOperationsResearch|Hillier e Lieberman (2014)]].\nO exemplo √© um tipo de [[Problema de localiza√ß√£o de facilidades]].\n\n\n### Pelo menos uma restri√ß√£o atendida\n\nConsidere duas restri√ß√µes como as a seguir\n\n$$\\begin{cases}2x_1 + 3x_2 \\leq 20,\\\\ 5x_1 + 2x_2 \\leq 18.\\end{cases}$$\n\nDeseja-se que pelo menos uma dessas restri√ß√µes seja atendida, mas n√£o necessariamente ambas. \n\nUma forma de realizar isso √© utilizar uma vari√°vel auxiliar $y \\in \\{0, 1\\}$.\n\n$$y = \\begin{cases}0, \\text{ se } 2x_1 + 3x_2 \\leq 20\\\\ 1, \\text{ se } 5x_1 + 2x_2 \\leq 18\\end{cases}$$\n\nEnt√£o, seja $M$ um n√∫mero grande, podemos modelar a situa√ß√£o como:\n\n$$\\begin{cases}2x_1 + 3x_2 \\leq 20 + My,\\\\ 5x_1 + 2x_2 \\leq 18 + M(1 - y).\\end{cases}$$\n\nEssa t√©cnica √© √∫til, por exemplo, para modelos do [[Problema de corte e empacotamento]].\n\n### $K$ de $T$ restri√ß√µes atendidas\n\nA ideia anterior pode ser adaptada para atender $K$ de um conjunto com $T$ restri√ß√µes. Considere as $T$ restri√ß√µes a seguir.\n\n$$a_{11}x_{1} + \\ldots + a_{1n}x_n \\leq b_1,$$\n$$a_{21}x_{1} + \\ldots + a_{2n}x_n \\leq b_2,$$\n$$\\vdots$$\n$$a_{T1}x_{1} + \\ldots + a_{Tn}x_n \\leq b_T,$$\n\ndas quais √© necess√°rio atender pelo menos $K$. Para isso, seja $y_i \\in \\{0, 1\\}, i=1, \\ldots, T$, que recebe valor $0$ se a $i$-√©sima restri√ß√£o √© atendida. \n\nEnt√£o, pode-se escrever\n\n$$a_{11}x_{1} + \\ldots + a_{1n}x_n \\leq b_1 + My_1,$$\n$$a_{21}x_{1} + \\ldots + a_{2n}x_n \\leq b_2 + My_2,$$\n$$\\vdots$$\n$$a_{T1}x_{1} + \\ldots + a_{Tn}x_n \\leq b_M + My_2,$$\n$$\\sum_{i=1}^Ty_i = T - K$$\n\n\n### Custo fixo\n\nO custo fixo ocorre quando h√° um custo inicial para um atividade. Por exemplo, o setup de uma atividade e o in√≠cio de uma corrida de aplicativo. \n\nComo exemplo, considere que foi feito um pedido para um aplicativo de transporte, o custo por quil√¥metro de viagem √© de $c$, mas √© pago um custo fixo, ao in√≠cio da corrida de $k$. O objetivo √© modelar a fun√ß√£o de custo $f(x)$ em fun√ß√£o da dist√¢ncia percorrida $x$.\t\n\n$$f(x) = \\begin{cases}k + cx \\text{ se } x \u003e 0,\\\\ 0, \\text{ se } x \\leq 0.\\end{cases}$$\n\nPara a constru√ß√£o do modelo, pode-se utilizar uma vari√°vel auxiliar $y \\in \\{0, 1\\}$ que toma valor 1 se $x \u003e 0$ e 0 caso contr√°rio. \n\nCom isso, pode-se definir $$z = f(x, y) = ky + cx,$$ com a adi√ß√£o da restri√ß√£o $$x \\leq My,$$ onde $M$ √© um valor grande.\n\n\n## Aplica√ß√µes\n\n- De [[2020Wolsey_IntegerProgramming|Wolsey (2020)]]\n\t\u003e *Scheduling* de trens. A agenda de alguns trens √© peri√≥dica. Para cada linha, os tempos de viagem entre as esta√ß√µes √© conhecido e o tempo de perman√™ncia em cada esta√ß√£o deve estar dentro de um intervalo. Dois trens viajando na mesma linha devem estar separados por um dado n√∫mero de minutos. Para permitir a conex√£o de passageiros entre dois trens deve haver um intervalo entre a chegada do trem A e a partida do trem B. O problema √© encontrar uma agenda fact√≠vel para um conjunto de trens e linhas\n\n\t\u003e Escalonamento de tripula√ß√£o a√©rea\n\n\t\u003e Planejamento de produ√ß√£o\n\n\t\u003e Planejamento da gera√ß√£o de eletricidade\n\n\t\u003e Telecomunica√ß√µes\n\n\t\u003e Tratamento de radio-terapia\n\n\t\u003e Programas de transplante de rins\n\n\t\u003e Problemas de corte\n\n# Refer√™ncias\n- Wolsey, Laurence A. _Integer programming_. John Wiley \u0026 Sons, 2020.\n- Hillier, F. S., and G. J. Lieberman. \"edition 10. Introduction to operations research.\" (2014).\n","lastmodified":"2022-10-19T15:09:54.834727215Z","tags":null},"/vault/Otimiza%C3%A7%C3%A3o/O-que-%C3%A9-otimiza%C3%A7%C3%A3o-combinat%C3%B3ria":{"title":"Otimiza√ß√£o combinat√≥ria","content":"\n# Introdu√ß√£o √† otimiza√ß√£o combinat√≥ria\n\nProblemas combinat√≥rios consistem em encontrar um (ou v√°rios) elementos de um conjunto que satisfaz (em) restri√ß√µes pr√©-definidas. Existem alguns tipos de problemas diferentes: \n\n1. Encontrar uma solu√ß√£o satisfazendo um conjunto de restri√ß√µes.\n2. Encontrar todas as solu√ß√µes satisfazendo um conjunto de restri√ß√µes.\n3. Encontrar uma solu√ß√£o √≥tima de acordo com uma fun√ß√£o objetivo. \n\nProblemas de Otimiza√ß√£o Combinat√≥ria s√£o problemas combinat√≥rios que potencialmente admitem mais de uma solu√ß√£o e essas solu√ß√µes s√£o diferenciadas por uma medida de qualidade, a fun√ß√£o objetivo. \n\nDiversos problemas de otimiza√ß√£o combinat√≥ria s√£o NP-dif√≠ceis. Simplificadamente, isso faz com que o tempo de resolu√ß√£o cres√ßa exponencialmente com o tamanho do problema. Por isso, algoritmos baseados na enumera√ß√£o expl√≠cita de cada solu√ß√£o vi√°vel conseguem resolver apenas inst√¢ncias pequenas de tais problemas. Por isso, frequentemente, inst√¢ncias de interesse pr√°tico, demandam por estrat√©gias mais sofisticadas de solu√ß√£o. \n\nDuas dessas estrat√©gias s√£o: m√©todos exatos e m√©todos heur√≠sticos. Os m√©todos exatos, como o branch-and-cut, s√£o m√©todos que garantem a otimalidade da solu√ß√£o encontrada desde que uma demanda por recursos computacionais (tempo e mem√≥ria) possa ser atendida. M√©todos heur√≠sticos s√£o m√©todos que relaxam a busca por solu√ß√µes √≥timas em prol da obten√ß√£o de uma solu√ß√£o boa em tempo computacional reduzido.\n\n![[attachments/Pasted image 20220908151703.png]]\n\nDentre os m√©todos exatos est√° o arcabou√ßo conhecido como [[Branch-and-cut||branch-and-cut]]. A implementa√ß√£o de algoritmos de [[vault/Otimiza√ß√£o/Branch-and-cut|branch-and-cut]] para um problema costuma ser n√£o trivial. Para garantir a efici√™ncia de tais algoritmos √© necess√°rio combinar estrat√©gias de pr√©-processamento, explora√ß√£o de √°rvores de branch-and-bound, planos de corte, entre outros. Nesse caso, √© necess√°rio construir problemas auxiliares para a obten√ß√£o de limitantes duais para o problema a ser resolvido. O arcabou√ßo de branch-and-cut √© de tamanha import√¢ncia que h√° diversos pacotes computacionais que fornecem uma implementa√ß√£o pronta como [[Gurobi]], [[SCIP]], [[CPlex]] e [[Cbc]]. Para utilizar tais pacotes √© necess√°rio conseguir escrever o problema utilizando o paradigma de [[vault/Otimiza√ß√£o/Modelagem para programas lineares inteiros|Programa√ß√£o Linear e Inteira]]. \n\nM√©todos de solu√ß√£o heur√≠sticos relaxam a garantia de otimalidade da solu√ß√£o em prol de reduzir os recursos computacionais necess√°rios, em geral, deseja-se obter uma solu√ß√£o de boa qualidade (n√£o necessariamente √≥tima) mais rapidamente. Existem diversas estrat√©gias heur√≠sticas, meta-heur√≠sticas, que podem ser aplicadas a in√∫meros problemas. Entre eles est√£o [[algoritmos gen√©ticos]], [[algoritmos de col√¥nias de formigas]], [[otimiza√ß√£o por enxame de particulas]], [[busca tabu]], [[simulated annealing]], [[iterated local search]], [[variable neighborhood search]],  e muitos outros.","lastmodified":"2022-10-19T15:09:54.834727215Z","tags":null},"/vault/Otimiza%C3%A7%C3%A3o/Problema-do-Caixeiro-Viajante":{"title":"O problema do caixeiro viajante","content":"\n# \n# O Problema do Caixeiro Viajante\n\nUm vendedor deseja visitar as cidades $0, 1, 2, \\ldots, n-1$, partindo de uma delas. O custo de viajar de uma cidade $i$ para uma cidade $j$ √© $c_{ij}$, $i, j = 0, 1, \\ldots, n-1$. O problema de determinar uma rota com o menor custo que visita todas as cidades exatamente uma vez √© conhecido como Problema do Caixeiro Viajante.\n\n\n\n## Modelo de programa√ß√£o linear inteira\n\n- Vari√°veis\n\t- $x_{ij} \\in \\{0, 1\\}$: Indica se um arco $(i, j)$ √© utilizado ou n√£o.\n\t- $0 \\leq u_i \\leq n-1$: Indica a ordem do $i$ n√≥ na rota.\n- Fun√ß√£o objetivo:\n\t- $$\\min \\sum_{i = 0}^{n-1} \\sum_{j=0}^{n-1} c_{ij}x_{ij}$$\n- Restri√ß√µes\n\t- $$\\sum_{j=1, i \\neq j}^n x_{ij} = 1 \\quad i \\in \\{0, 1, \\ldots, n-1\\}$$\n\t- $$\\sum_{j=1, i \\neq j}^n x_{ji} = 1 \\quad i \\in \\{0, 1, \\ldots, n-1\\}$$\n\t- $$u_j \\geq u_i + 1 - (n-1)(1 - x_{ij}) \\quad i, j \\in \\{1, 2, \\ldots, n-1\\}, i \\neq j$$\n\t- $$x_{ij} \\in \\{0, 1\\} \\quad i, j \\in \\{0, 1, \\ldots, n-1\\}$$\n\t- $$0 \\leq u_i \\leq n-1 \\quad i \\in \\{0, 1, \\ldots n-1\\}$$\n\t\n\n## Exemplo de c√≥digo\n\n### [[Gurobi]]\n\n### [[Python-mip]]\n\n```python\nfrom random import randint, seed\nfrom itertools import product\nfrom mip import Model, xsum, minimize, BINARY, CONTINUOUS\n\nseed(2)\ndef generate_data(n_points):\n    points = []\n    for i in range(n_points):\n        points.append((randint(0, 100), randint(0, 100)))        \n    return points\n\ndef compute_dist_matrix(points):\n    dist = {}\n    for i, p1 in enumerate(points):\n        for j, p2 in enumerate(points):\n            dist[i, j] = ((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)**0.5\n    return dist\n\ndef plot_solution(points, tour):\n    import matplotlib.pyplot as plt    \n    xs, ys = zip(*points)\n    plt.scatter(xs, ys)\n    lines_x = []\n    lines_y = []\n    for v in tour:\n        lines_x.append(xs[v])\n        lines_y.append(ys[v])\n        plt.annotate(v, (xs[v]*1.01, ys[v]*1.01), fontsize=10)\n    lines_x.append(xs[tour[0]])\n    lines_y.append(ys[tour[0]])\n    plt.plot(lines_x, lines_y)    \n    plt.grid('on')\n    plt.show()\n\nn_points = 20\nV = set(range(n_points))\npoints = generate_data(n_points)\nc = compute_dist_matrix(points)\n\nmodel = Model()\nx = {}\nfor i in V:\n    for j in V:\n        x[i, j] = model.add_var(var_type=BINARY, name=\"x[%d, %d]\" % (i, j))\n\nu = [model.add_var(var_type=CONTINUOUS, lb=0, ub=n_points-1, name=\"u[%d]\" % i)\n    for i in V]\n\nmodel.objective = minimize(xsum(c[i, j]*x[i, j] for i in V for j in V))\n\nfor i in V:\n    model += xsum(x[i, j] for j in V - {i}) == 1\n\nfor i in V:\n    model += xsum(x[j, i] for j in V - {i}) == 1\n\nfor (i, j) in product(V - {0}, V - {0}):\n    if i != j:\n        model += u[j] \u003e= u[i] + 1 - (n_points-1)*(1 - x[i, j])\n\nmodel.optimize()\n\nif model.num_solutions \u003e 0:\n    print(\"Solution found:\")\n    print(\"Used arcs:\")\n    for (i, j) in product(V, V):\n        if x[i, j].x \u003e 0.5:\n            print(\"({}, {})\".format(i, j))\n    tour = sorted(list(V), key=lambda i:u[i].x)\n    print(\"Tour:\", tour)\n#    plot_solution(points, tour)\n```\n\n### [[Or-tools]]\n\n","lastmodified":"2022-10-19T15:09:54.834727215Z","tags":null},"/vault/Otimiza%C3%A7%C3%A3o/Vis%C3%A3o-geral-de-otimiza%C3%A7%C3%A3o":{"title":"Vis√£o geral","content":"\n- [[O que √© otimiza√ß√£o combinat√≥ria]]\n- Solu√ß√µes para problemas de otimiza√ß√£o combinat√≥ria\n\t- [[Enumerando solu√ß√µes explicitamente]]\n\t- [[Enumera√ß√£o impl√≠cita de solu√ß√µes]]\n\t- [[Modelagem para programas lineares inteiros]]\n- Problemas cl√°ssicos de Programa√ß√£o Linear Inteira Mista\n\t- Modelos de tamanho polinomial\n\t\t- Implementa√ß√£o de modelos em pacotes computacionais\n\t- Modelos de tamanho exponencial\n\t\t- Gera√ß√£o de colunas\n\t\t\t- Algoritmo Simplex\n\t\t- Decomposi√ß√£o de Benders\n- Avalia√ß√£o de modelos de programa√ß√£o linear inteira\n\t- Desigualdades v√°lidas,\n\t- algoritmos de planos de corte,\n- Limitantes e relaxa√ß√µes\n\t- Relaxa√ß√£o linear\n\t- Relaxa√ß√£o surrogate\n\t- Relaxa√ß√£o lagrangeana\n\t- Relaxa√ß√£o combinat√≥ria\n- [[Branch-and-bound]] como m√©todo para Programa√ß√£o Linear Inteira\n\t- Solu√ß√µes sim√©tricas\n\n","lastmodified":"2022-10-19T15:09:54.834727215Z","tags":null},"/vault/calculo-numerico/Elimina%C3%A7%C3%A3o-de-Gauss":{"title":"Elimina√ß√£o de Gauss","content":"\n# Elimina√ß√£o de Gauss\n\nO m√©todo da elimina√ß√£o de Gauss √© um m√©todo eliminativo para a solu√ß√£o de sistemas lineares, $Ax = b$. O m√©todo est√° baseado em uma propriedade da √Ålgebra Linear que garante que uma solu√ß√£o $x$ do sistema $Ax=b$ obedece qualquer combina√ß√£o linear das equa√ß√µes do sistema. A ideia fundamental √© transformar o sistema linear $Ax=b$ em um [[vault/calculo-numerico/Sistemas lineares equivalentes|sistema linear equivalente]] de mais f√°cil solu√ß√£o atrav√©s do processo de escalonamento.\n\nS√£o utilizadas tr√™s opera√ß√µes para simplificar o sistema linear a ser resolvido:\n1. Uma equa√ß√£o $L_i$ pode ser multiplicada por uma constante n√£o nula $\\lambda$ com o resultado substituindo a equa√ß√£o $L_i$. $(\\lambda L_i) \\rightarrow (L_i)$\n2. Uma equa√ß√£o $L_j$ pode ser multiplicada por uma constante $\\lambda$ e somada √† equa√ß√£o $L_i$ com o resultado substituindo $L_i$. $(L_i + \\lambda L_j) \\rightarrow (L_i)$\n3. As equa√ß√µes $L_i$ e $L_j$ podem ser permutadas. \n\nComo uma sequ√™ncia finita dessas opera√ß√µes, pode-se simplificar o sistema $Ax = b$, transformando-o em um sistema equivalente $A_1x=b_1$ com $A_1$ triangular superior.\n\n## Exemplo\n\nConsidere o sistema $Ax = b$ a seguir. \n\n$$\n\\left\\{\n\\begin{alignat}{4}\n\u0026x_1 + 2x_2 + x_3 = 8\\\\\n-2\u0026x_1 + x_2 + 3x_3 = 9\\\\\n4\u0026x_1 - x_2 - x_3 = -1\n\\end{alignat}\n\\right.\n$$\nPode-se escrever o sistema utilizando a forma matricial estendida $[A\\ \\vdots\\ b]$.\n\n$$\n\\begin{bmatrix}\n1 \u0026 2 \u0026 1 \u0026 8\\\\\n-2 \u0026 1 \u0026 3 \u0026 9\\\\\n4 \u0026 -1 \u0026 -1 \u0026 -1\n\\end{bmatrix}\n$$\nPara o processo de triangulariza√ß√£o, tomam-se os elementos da diagonal principal de $A$ como piv√¥s para anular os elementos abaixo da diagional, um por vez. Portanto, utilizando como piv√¥ o elemento $a_{11} = 1$ tem-se:\n\n1. $\\lambda = \\frac{a_{21}}{a_{11}} = -2$ e $(L_2 - \\lambda L_1) \\rightarrow (L_2)$.\n2. $\\lambda  = \\frac{a_{31}}{a_{11}} = 4$ e $(L_3 - \\lambda L_1) \\rightarrow (L_3).$\n\nResultando na matriz:\n\n$$\n\\begin{bmatrix}\n1 \u0026 2 \u0026 1 \u0026 8\\\\\n0 \u0026 5 \u0026 5 \u0026 25\\\\\n0 \u0026 -9 \u0026 -5 \u0026 -33\n\\end{bmatrix}.\n$$\n\nEnt√£o, se utiliza o piv√¥ $a_{22} = 5$ para dar anular os elementos da segunda coluna abaixo da diagonal.\n1. $\\lambda = \\frac{a_{32}}{a_{22}} = -9$ e $(L_3 - \\lambda L_2) \\rightarrow (L_3)$.\n\ne tem-se:\n$$\n\\begin{bmatrix}\n1 \u0026 2 \u0026 1 \u0026 8\\\\\n0 \u0026 5 \u0026 5 \u0026 25\\\\\n0 \u0026 0 \u0026 4 \u0026 12\n\\end{bmatrix}.\n$$\n\nNote que a matriz $A$ foi transformada em $A_1$ triangular superior. A vantagem de resolver sistemas triangulares √© que basta realizar substitu√ß√£o de vari√°veis. \n\nPara o exemplo apresentado, o procedimento de retro-substitui√ß√£o √© dado por\n$$\n\\begin{align}\nx_3 \u0026= \\frac{12}{4} = 3\\\\\nx_2 \u0026= \\frac{1}{5}(25 - 5x_3) = 2\\\\\nx_1 \u0026= \\frac{1}{1}(8 - x_3 - 2x_2) = 1\\\\\n\\end{align}\n$$\nO procedimento da Elimina√ß√£o de Gauss pode ser dividido em dois passos:\n1. Realizar a triangulariza√ß√£o do sistema.\n2. Realizar a retrossubstitui√ß√£o das vari√°veis.\n\n\u003e [!Warning] Piv√¥s nulos\n\u003e No caso de um piv√¥ nulo $a_{kk}$, √© necess√°rio buscar nas linhas $i \u003e k$ por um piv√¥ n√£o nulo. Preferencialmente, busca-se pelo maior piv√¥ em m√≥dulo. Um procedimento conhecido como **pivoteamento parcial**.\n\n## Avaliando o erro\n\nConsidere o sistema\n\n$$\n\\left\\{\n\\begin{align}\n\u00260.896x_1 + 1.664x_2 + 0.386x_3 = 2\\\\\n\u00260.842x_1 + 1.568x_2 - 0.414x_3 = 0\\\\\n-\u00260.638x_1 + 1.768x_2 + 0.558x_3 = 0\\\\\n\\end{align}\n\\right.\n$$\n\nResolvendo utilizando elimina√ß√£o de Gauss, com 4 casas decimais de precis√£o.\n\n#todo Resolver o sistema\n\n\nUma medida de erro frequentemento utilizada √© relacionada a o res√≠duo de cada equa√ß√£o $$R_i = a_{i1}x_1 + a_{i2}x_2 + \\ldots a_{in}x_n - b_i.$$\nNo caso de n√£o haver erros num√©ricos, espera-se que os res√≠duos $R_i, i =1, 2, \\ldots, n$ sejam nulos. Na pr√°tica, se utiliza como crit√©rio de erro o maior res√≠duo absoluto $$erro = \\max\\{|R_i|: i = 1, 2, \\ldots, n\\}.$$\n\n## Pivoteamento parcial\n\n\n## Pivoteamento total\n\n## Uma implementa√ß√£o\n\n```python\ndef gauss_elimination(A):\n    # Matriz A √© a matriz estendida do sistema\n    n = A.shape[0]\n    for k in range(n-1):\n        for i in range(k+1, n):\n            q = A[i, k]/A[k, k]\n            for j in range(k+1, n+1):                \n                A[i, j] = A[i, j] - q * A[k, j]\n            A[i, k] = 0.0\n    x = np.zeros(n)\n    x[n-1] = A[n-1, n]/A[n-1, n-1]\n    for i in range(n-2, -1, -1):\n        x[i] = (A[i, n] - np.dot(A[i, i+1:n], x[i+1:]))/A[i, i]\n    return x\n```\n\n### An√°lise do custo do algoritmo\n\n# Refer√™ncias\n- Peters, S√©rgio, e Julio Felipe Szeremeta. C√°lculo num√©rico computacional (2019).\n- Burden, R. L., Faires, J. D., \u0026 Burden, A. M. (2015). _Numerical analysis_. Cengage learning.","lastmodified":"2022-10-19T15:09:54.834727215Z","tags":null},"/vault/calculo-numerico/M%C3%A9todo-de-Gauss-Seidel":{"title":"M√©todo de Gauss-Seidel","content":"\n```python\ndef gauss_seidel(A, b, x, stop_error=1e-10, max_iter=1000):\n    iter = 0\n    error = compute_erro(A, b, x)\n    n = len(x)\n    while error \u003e stop_error and iter \u003c max_iter:\n        for i in range(n):\n            sum1 = np.dot(A[i, :i], x[:i])\n            sum2 = np.dot(A[i, i+1:], x[i+1:])\n            x[i] = 1/A[i, i]*(b[i] - sum1 - sum2)\n        error = compute_erro(A, b, x)\n        iter += 1\n    return x\n```","lastmodified":"2022-10-19T15:09:54.834727215Z","tags":null},"/vault/calculo-numerico/M%C3%A9todo-de-Jacobi":{"title":"M√©todo de Jacobi","content":"\n```python\ndef jacobi(A, b, x, stop_error=1e-10, max_iter=1000):\n    iter = 0\n    error = compute_erro(A, b, x)\n    n = len(x)\n    x_ant = np.copy(x)\n    while error \u003e stop_error and iter \u003c max_iter:\n        for i in range(n):\n            sum1 = np.dot(A[i, :i], x[:i])\n            sum2 = np.dot(A[i, i+1:], x[i+1:])\n            x_ant[i] = 1/A[i, i]*(b[i] - sum1 - sum2)\n        x = np.copy(x_ant)\n        error = compute_erro(A, b, x)\n        iter += 1\n    return x\n```","lastmodified":"2022-10-19T15:09:54.834727215Z","tags":null},"/vault/calculo-numerico/M%C3%A9todo-de-Newton-para-equa%C3%A7%C3%B5es":{"title":"M√©todo de Newton","content":"\n# O m√©todo de Newton-Raphson\n\n## Notas hist√≥ricas\n\n\u003e Publica√ß√£o do m√©todo √© de 1685 (por Isaac Newton).\n\u003e Em 1960, Joseph Raphson publicou uma descri√ß√£o simplificado.\n\u003e Em 1740, Thomas Simpson descreveu o m√©todo para equa√ß√µes n√£o lineares.\n\nEmbora o nome do m√©todo seja derivado de [Isaac Newton](https://pt.wikipedia.org/wiki/Isaac_Newton). A descri√ß√£o do m√©todo que vamos estudar √© substancialmente diferente do utilizado originalmente por Newton. A primeira publica√ß√£o desse m√©todo √© datada de 1685. Em 1690, [Joseph Raphson ](https://en.wikipedia.org/wiki/Joseph_Raphson), publicou uma descri√ß√£o simplificado. Por isso, o m√©todo √© muitas vezes chamado de M√©todo de Newton-Raphson. Newton e Raphson aplicaram o m√©todo exclusivamente para polin√¥mios, foi apenas em 1740 que [Thomas Simpson](https://en.wikipedia.org/wiki/Thomas_Simpson) descreveu o m√©todo como um m√©todo iterativo para resolver equa√ß√µes n√£o lineares usando [[C√°lculo]]. Essencialmente, essa √© a descri√ß√£o que ser√° apresentada aqui.\n\n## Descri√ß√£o do m√©todo\n\nO m√©todo de Newton pode ser utilizado para resolver equa√ß√µes $f(x) = 0$, $f: \\mathbb{C} \\rightarrow \\mathbb{C}$. Por enquanto, vamos nos concentrar no caso em que $f: \\mathbb{R} \\rightarrow \\mathbb{R}$. Note que encontrar uma raiz para equa√ß√£o $f(x) = 0$ √© equivalente a encontrar um zero da fun√ß√£o $f(x)$.\n\nConsidere o polin√¥mio $$P(x) = x^5 + x^2 - 1$$\nCujo o gr√°fico √© dado a seguir:\n\n\u003ciframe src=\"https://www.desmos.com/calculator/ilgfeuouji?embed\" width=\"500\" height=\"500\" style=\"border: 1px solid #ccc\" frameborder=0\u003e\u003c/iframe\u003e\n\nPara encontrar uma raiz da equa√ß√£o $P(x) = 0$, a ideia do m√©todo √© produzir uma aproxima√ß√£o inicial para $x_0$ para tal raiz. Por exemplo, $x_0 = 1$. \n\nNo ponto $(x_0, P(x_0)) = (1, 1)$ utiliza-se uma aproxima√ß√£o linear para $P(x)$. Isto √©, tra√ßa-se a reta $r(x)$ tangente a $P(x)$ em $x_0$. A reta √© dada por:\n\n$$r(x) = P(x_0) + P'(x_0)(x - x_0),$$\nou seja,  $r(x) = 1 + 7(x - 1)$.\n\n\u003ciframe src=\"https://www.desmos.com/calculator/6icuole2bi?embed\" width=\"500\" height=\"500\" style=\"border: 1px solid #ccc\" frameborder=0\u003e\u003c/iframe\u003e\n\nA pr√≥xima aproxima√ß√£o para a raiz de $P(x) = 0$ √© dada pelo valor $x_1$ que correspondente ao ponto em que a reta $r(x)$ se encontra com o eixo horizontal. Ent√£o, √© necess√°rio encontrar o valor de $\\Delta x= x_1 - x_0$. Note que $\\frac{P(x_0)}{-\\Delta x} = P'(x_0)$ e tem-se:\n\n$$- \\Delta x = \\frac{P(x_0)}{P'(x_0)} \\quad \\Rightarrow \\quad x_1 = x_0 - \\frac{P(x_0)}{P'(x_0)}.$$\nEnt√£o, pode-se repetir o processo para gerar uma sequ√™ncia de aproxima√ß√µes $(x_0, x_1, x_2, \\ldots)$ para uma raiz da equa√ß√£o $f(x) = 0$, definindo a rela√ß√£o de recorr√™ncia a seguir, para uma escolha de $x_0$.\n\n$$x_{k+1} = x_k - \\frac{f(x_k)}{f'(x_{k})}, \\quad k = 1, 2, \\ldots,$$\n### Crit√©rios de erro\nAlgumas medidas de erro que podem ser utilizadas como crit√©rio de parada para o M√©todo de Newton.\n- $|x_{k+1} - x_k| \u003c \\epsilon$. Esse crit√©rio pode n√£o ser adequado quando a sequ√™ncia converge lentamente.\n- $\\frac{|x_{k+1} - x_k|}{|x_{k+1}|} \u003c \\epsilon$. Interessante quando $x_{k+1}$ √© muito pequeno (mas n√£o nulo), ou muito grande.\n- $|f(x_{k+1})| \u003c \\epsilon$. Esse crit√©rio pode n√£o ser adequado quando $f(x_k)$ possui valores pequenos.\n- $|f(x_{k+1})| + \\frac{|x_{k+1} - x_k|}{|x_{k+1}|} \u003c \\epsilon$. Comp√µe dois anteriores, √© mais conservador.\n\n## Exemplos\n- Utilizando o m√©todo de Newton para encontrar um zero da fun√ß√£o $f(x) = cos(x) - x$,  com aproxima√ß√£o inicial $x_0 = 0$. \n\t- Primeira itera√ß√£o:\n\t\t- $x_0 = 0$.\n\t\t- $x_1 = x_0 - f(x_0)/f'(x_0) = 0 - (cos(0) - 0)/(-sin(0) - 1) = 1$.\n\t\t- $erro = \\frac{|x_1 - x_0|}{|x_1|} = 1.$\n\t- Segunda itera√ß√£o:\n\t\t- $x_1 = 1$.\n\t\t- $x_2 = x_1 - f(x_1)/f'(x_1) = 1 - (-0.4597)/(-1.841) = 0.7503$.\n\t\t- $erro = \\frac{|0.7503 - 1|}{|0.7503|} = 0.3328$.\n\t- Terceira itera√ß√£o:\n\t\t- $x_2 = 0.7503$.\n\t\t- $x_3 = x_2 - f(x_2)/f'(x_2) = 0.7503 - (-0.01882)/(-1.682) = 0.7391$.\n\t\t- $erro = \\frac{|0.7391 - 0.7503|}{|0.7391|} = 0.01515$.\n\n- Como um outro exemplo, considere a fun√ß√£o $f(x) = x^{\\frac{1}{3}}$. A rela√ß√£o de recorr√™ncia do m√©todo de Newton para essa fun√ß√£o √© dada por $$x_{k+1} = x_k - \\frac{x^{\\frac{1}{3}}}{\\frac{1}{3}x^{-\\frac{2}{3}}} = -2x_k.$$ Portanto, independente de qual aproxima√ß√£o inicial (n√£o nula) for utilizada, a sequ√™ncia gerada ser√° divergente. Por exemplo, $x_0 = 1$ a sequ√™ncia gerada seria $(1, -2, 4, -8, 16, -32, \\ldots).$  Isso mostra que a sequ√™ncia gerada pelo m√©todo de Newton n√£o possui garantia de converg√™ncia. \n\n- Considere a equa√ß√£o polinomial $x^3 - 2x + 2 = 0$, ao se tentar encontrar uma raiz da equa√ß√£o utilizando o m√©todo de Newton, com $x_0 = 0$. Observe o que ocorre.\n\t- $x_{1} = x_0 - \\frac{x_0^3 - 2x_0 + 2}{3x_0^2 - 2} = 0 - \\frac{2}{-2} = 1$\n\t- $x_2 = x_1 - \\frac{x_1^3 - 2x_1 +2}{3x_1^2-2} = 1 - \\frac{1}{1} = 0$\n\t- $x_3 = 1, x_4 =0, \\ldots,$ sem nunca convergir.\n\t- graficamente, tem-se o seguinte: \n\t- \u003ciframe src=\"https://www.desmos.com/calculator/epndu9typm?embed\" width=\"500\" height=\"500\" style=\"border: 1px solid #ccc\" frameborder=0\u003e\u003c/iframe\u003e\n\t- Note que esse exemplo √© apenas para ilustrar uma situa√ß√£o poss√≠vel de oscila√ß√£o entre os valores. Na pr√°tica, √© poss√≠vel encontrar uma raiz de polin√¥mios c√∫bicas utilizando o [m√©todo de Cardano-Tartaglia](https://pt.wikipedia.org/wiki/Equa%C3%A7%C3%A3o_c%C3%BAbica). Ali√°s, a solu√ß√£o de equa√ß√µes c√∫bicas est√° relacionada a uma novela matem√°tica e √† inven√ß√£o de n√∫meros imagin√°rias ([saiba mais](https://youtu.be/cUzklzVXJwo)).  \n\n\nOs exemplos anteriores lan√ßam uma d√∫vida sobre o m√©todo. Afinal, o m√©todo de Newton √© confi√°vel? Ser√° que ele √© eficiente comparado ao [[M√©todo da biparti√ß√£o]] ou o [[M√©todo da falsa-posi√ß√£o]]? Exploraremos tais aspectos a seguir.\n\n## Considera√ß√µes sobre a converg√™ncia\n\nVimos no exemplo da fun√ß√£o $f(x) = x^{\\frac{1}{3}}$ que n√£o h√° garantia de converg√™ncia da sequ√™ncia gerada pelo m√©todo de Newton. Outra pergunta importante √©: no caso de converg√™ncia da sequ√™ncia, essa converg√™ncia √© necessariamente para a raiz de $f(x) = 0$?\n\nSupondo que $x_{k},\\ k = 0, 1, 2, \\ldots$ converge para um valor final $\\alpha$, isto √©,\n$$\n     \\lim_{k \\to \\infty} x_{k+1} = \\lim_{k \\to \\infty}x_{k} = \\alpha,\n$$\n\n aplicando esses limites na  express√£o de recorr√™ncia, tem-se:\n\n$$\n\\lim_{k \\to \\infty} x_{k+1} = \\lim_{k \\to \\infty} x_{k} - \\lim_{k \\to \\infty}\n\\frac{f(x_{k})}{f'(x_{k})}, \n$$\n$$\\lim_{k \\to \\infty} x_{k+1} = \\lim_{k \\to \\infty} x_{k} -\n\\frac{\\lim_{k \\to \\infty}f(x_{k})}{\\lim_{k \\to \\infty}f'(x_{k})}$$\n\nComo $f(x)$ e $f'(x)$ s√£o cont√≠nuas, tem-se:\n$$\n\\lim_{k \\to \\infty} f(x_{k}) = f(\\lim_{k \\to \\infty} x_{k}) \n$$\ne $$\\lim_{k \\to \\infty} f'(x_{k}) = f'(\\lim_{k \\to \\infty} x_{k})\n$$\n  Ent√£o, \n$$\n\\lim_{k \\to \\infty} x_{k+1} = \\lim_{k \\to \\infty} x_{k} - \\frac{\\displaystyle f(\\lim_{k \\to\n    \\infty}x_{k})}{\\displaystyle f'(\\lim_{k \\to \\infty} x_{k})}.\n$$\nComo $\\displaystyle \\lim_{k \\to \\infty}x_{k+1} = \\lim_{k \\to \\infty}x_{k} = \\alpha$, tem-se:\n\n$$\n\\alpha = \\alpha - \\frac{f(\\alpha)}{f'(\\alpha)}\n$$\nPortanto, $\\frac{f(\\alpha)}{f'(\\alpha)} = 0$ e $f(\\alpha) = 0$, desde que $f'(\\alpha) \\neq 0$. Logo, $\\alpha$ √© solu√ß√£o de $f(x) = 0$. \nAssim, se a sequ√™ncia gerada pela equa√ß√£o de recorr√™ncia for convergente, o seu limite sempre ser√° solu√ß√£o de $f(x) = 0$.\n\n## Considera√ß√µes sobre a converg√™ncia\n\nA converg√™ncia do m√©todo de Newton √© quadr√°tica.\n\n## M√©todo de Newton para ra√≠zes complexas\n\nConsidere o polin√¥mio $P(x) = x^6 + 64$, que possui uma raiz complexa $x = 2i$. Para que o m√©todo de Newton consiga gerar uma sequ√™ncia convergente para a raiz $x = 2i$, √© necess√°rio para que a aproxima√ß√£o inicial tenha uma componente imagin√°ria $x_0 = a + bi, b \\neq 0$. \n\nPor exemplo, supondo $x_0 = i$, tem-se:\n$$x_1 = x_0 - \\frac{x_0^6 + 64}{6x_0^5} = 11.5i,$$\n$$x_2 = 9.58339i,$$\n$$x_3 = 7.98629i,$$\n$$x_4 = 6.5557i,$$\ne, assim por diante, at√© a converg√™ncia. Note que se $x_0 = 1+i$, o valor de converg√™ncia √© $1.7321 - 1.0000i$, que tamb√©m √© uma das ra√≠zes de $P(x) = 0$.\n\nA converg√™ncia do m√©todo de Newton para as ra√≠zes de polin√¥mios gera o chamado [Fractal de Newton](https://en.wikipedia.org/wiki/Newton_fractal). \n\u003ca href=\"https://upload.wikimedia.org/wikipedia/commons/d/db/Julia_set_for_the_rational_function.png\"\u003e\u003cimg alt=\"File:Julia set for the rational function.png\" src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/d/db/Julia_set_for_the_rational_function.png/800px-Julia_set_for_the_rational_function.png?20111026001115\" decoding=\"async\" srcset=\"https://upload.wikimedia.org/wikipedia/commons/thumb/d/db/Julia_set_for_the_rational_function.png/1200px-Julia_set_for_the_rational_function.png?20111026001115 1.5x, https://upload.wikimedia.org/wikipedia/commons/thumb/d/db/Julia_set_for_the_rational_function.png/1600px-Julia_set_for_the_rational_function.png?20111026001115 2x\" data-file-width=\"2000\" data-file-height=\"1500\" width=\"720\" height=\"540\"\u003e\u003c/a\u003e\n---\n# Refer√™ncias e outros materiais\n- Peters, S√©rgio, e Julio Felipe Szeremeta. C√°lculo num√©rico computacional (2019).\n- Newton's method produces this fractal, why don't we teach it in calculus classes? by 3Blue1Brown. Dispon√≠vel em: https://youtu.be/-RdOwhmqP5s.\n- Newton's method. Dispon√≠vel em: https://en.wikipedia.org/wiki/Newton's_method","lastmodified":"2022-10-19T15:09:54.834727215Z","tags":null},"/vault/calculo-numerico/M%C3%A9todos-de-Runge-Kutta":{"title":"M√©todos de Runge-Kutta","content":"","lastmodified":"2022-10-19T15:09:54.834727215Z","tags":null},"/vault/calculo-numerico/Resolu%C3%A7%C3%A3o-num%C3%A9rica-de-valores-de-problemas-iniciais":{"title":"Resolu√ß√£o de EDOs","content":"\n- M√©todos baseados no [[Teorema de Taylor]]\n\n## Um exemplo que vai e volta\n\nEqua√ß√£o do p√™ndulo\n\n$$\\frac{d^2\\theta}{dt^2} + \\frac{g}{L} sin(\\theta) = 0$$\n- $L$ √© o comprimento do p√™ndulo\n- $g \\approx 9.81\\frac{m}{s^2}$ √© a constante gravitacional \n\nPara valores pequenos de $\\theta$ pode-se utilizar a aproxima√ß√£o $sin(\\theta) \\approx \\theta$ simplificando o processo de solu√ß√£o da EDO.\n\nA equa√ß√£o diferencial de segunda ordem que representa o movimento do p√™ndulo, pode ser convertida em um sistema de EDOs de segunda ordem. Para isso, seja $y_1 = \\theta$, tem-se:\n\n- $\\dot{\\theta} = \\dot{y_1} = y_2$\n- $\\ddot{\\theta} = \\dot{y_2} = -\\frac{g}{L}sin(y_1)$\n\nA rela√ß√£o de recorr√™ncia para resolver o PVI utilizando o [[M√©todo de Euler]] √© dada por:\n- $y_1^{(k+1)} = y_1^{(k)} + h y_2^{(k)}$\n- $y_2^{(k+1)} = y_2^{(k)}-h\\frac{g}{L}sin(y_1^{(k)})$\n\n```python\nimport matplotlib.pyplot as plt\nimport math\n\ndef pendulum_func(y1, y2):\n    return y2, -g/L*math.sin(y1)\n\ng = 9.81 # m/s^2\nL = 0.1 # meters\ny1 = math.pi/4  # 45 degrees\ny2 = 0  # Initial velocity is zero\nt = 0\nT = 1 # Simulate until 1 second\nn = 100 # How many discretization steps\nh = (T-t)/n\npositions = [(t, y1)]\nwhile t \u003c T:\n    ret = pendulum_func(y1, y2)\n    y1, y2 = y1 + h*ret[0], y2 + h*ret[1]\n    t += h\n    positions.append((t, y1)) # Saving to plot\n\nt, y = zip(*positions)\nplt.plot(t, y)\nplt.show()\n```\n\nAs rela√ß√µes de recorr√™ncia, utilizando o [[M√©todos de Runge-Kutta|M√©todo de Runge-Kutta]] de segunda ordem s√£o\n\n```python\nimport matplotlib.pyplot as plt\nimport math\n\ndef pendulum_func(y1, y2):\n    return y2, -g/L*math.sin(y1)\n\ng = 9.81 # m/s^2\nL = 0.1 # meters\ny1 = math.pi/4  # 45 degrees\ny2 = 0  # Initial velocity is zero\nt = 0\nT = 1 # Simulate until 1 second\nn = 100 # How many discretization steps\nh = (T-t)/n\npositions = [(t, y1)]\nwhile t \u003c T:\n    K1 = pendulum_func(y1, y2)\n    K2 = pendulum_func(y1 + h*K1[0], y2+h*K1[1])\n    y1, y2 = y1 + h/2*(K1[0] + K2[0]), y2 + h/2*(K1[1] + K2[1])\n    t += h\n    positions.append((t, y1)) # Saving to plot\n\nt, y = zip(*positions)\nplt.plot(t, y)\nplt.show()\n```\n\n\n# Refer√™ncias\n\n- Burden, R. L., Faires, J. D., \u0026 Burden, A. M. (2015). _Numerical analysis_. Cengage learning.","lastmodified":"2022-10-19T15:09:54.834727215Z","tags":null},"/vault/calculo-numerico/Sistemas-lineares-equivalentes":{"title":"Sistemas lineares equivalentes","content":"\n# Sistemas lineares equivalentes\n\nSeja $S$ um sistema linear com $m$ equa√ß√µes e $n$ inc√≥gnitas, $Ax = b$. Um sistema linear equivalente a $S$ √© um sistema que pode ser obtido por meio da combina√ß√£o das seguintes opera√ß√µes: \n\n1. Permutar duas equa√ß√µes de $S$.\n2. Multiplicar uma das equa√ß√µes de $S$ por um n√∫mero real $\\lambda \\neq 0$\n3. Somar a uma das equa√ß√µes do sistema uma outra equa√ß√£o desse sistema multiplicada por um n√∫mero real. \n\n(Para o ponto 2, considere que) Se $x^*$ √© solu√ß√£o de $S$, ent√£o, tomando (sem perda de generalidade) a primeira linha do sistema, tem-se $$a_{11}x_1 + \\ldots + a_{1n}x_n = b_1.$$ Multiplicando a primeira linha por $\\lambda$, para obter um sistema $S_1$ tem-se:\n$$(\\lambda a_{11})x_1 + \\ldots + (\\lambda a_{1n})x_n = \\lambda b_1.$$\nPara a qual $x^*$ tamb√©m √© solu√ß√£o.\n\n(Para o ponto 3) √â poss√≠vel mostrar que um sistema $S_1$, gerado a partir de $S$ pela soma de duas equa√ß√µes, possui a mesma solu√ß√£o de $S$ ou s√£o ambos ($S_1$ e $S$), incompat√≠veis. Callioli et al. (1990) deixam a prova desse ponto como exerc√≠cio, deve ter sido por um bom motivo, ent√£o eu tamb√©m vou deixar. \n\n# Refer√™ncias\n- Carlos Callioli, Hygino Domingues, Roberto Costa. √Ålgebra linear e aplica√ß√µes 6¬™ Edi√ß√£o","lastmodified":"2022-10-19T15:09:54.834727215Z","tags":null},"/vault/calculo-numerico/Solu%C3%A7%C3%A3o-de-sistemas-lineares":{"title":"Solu√ß√£o de sistemas lineares","content":"\n# Solu√ß√£o de sistemas lineares\n\nConsidere o seguinte circuito el√©trico. \n\n![[attachments/Pasted image 20220926102430.png | 400]]\n\nDe acordo com as [Leis de Kirchoff](https://pt.wikipedia.org/wiki/Leis_de_Kirchhoff) a soma das tens√µes em cada malha e em cada n√≥ √© nula, ent√£o, podemos escrever o seguinte sistema. \n\n![[attachments/Pasted image 20220926103055.png|400]]\n\n$$\n\\begin{align}\n6i_1 + 5i_2 \u0026= 10\\\\\ni_1 - i_2 - i_3 \u0026= 0\\\\\n-5i_2 + 8i_3 + 2i_4 \u0026= 0\\\\\n3i_5 - 2i_4 \u0026= 0\\\\\ni_3 - i_4 - i_5 \u0026= 0\n\\end{align}\n$$\nTrata-se de um sistema linear. De uma forma geral, pode-se formular esse tipo de problema da seguinte forma:\n\n\u003e [!INFO]\n\u003e Um sistema linear $Ax = b$ com $n$ equa√ß√µes e $n$ vari√°veis √© dado por:\n\u003e $$\\begin{align}\n\u003e a_{11}x_1 + a_{12}x_2 + \\ldots + a_{1n}x_n \u0026= b_1,\\\\\n\u003e a_{21}x_1 + a_{22}x_2 + \\ldots + a_{2n}x_n \u0026= b_2,\\\\\n\u003e \\vdots\u0026\\\\\n\u003e a_{n1}x_1 + a_{n2}x_2 + \\ldots + a_{nn}x_n \u0026= b_1.\n\u003e \\end{align}$$\n\u003e com $a_{ij}$ e $b_i$ constantes e deseja-se determinar as vari√°veis $x_i$.\n\nOs m√©todos para resolver esse tipo de problema pode ser classificados em:\n1. M√©todos diretos (ou eliminativos), que garantem teoricamente que uma solu√ß√£o ser√° encontrada, caso exista.\n2. M√©todos iterativos. M√©todos iterativos geram uma sequ√™ncia de aproxima√ß√µes para a solu√ß√£o.\n3. M√©todos de Otimiza√ß√£o. M√©todos que constroem a fun√ß√£o $F(X) = x^tAx - 2b^tx$ e tenta-se encontrar o seu m√≠nimo, que √© solu√ß√£o do sistema.\n\n\u003e[!INFO] M√©todos diretos\n\u003e Exemplos de m√©todos diretos s√£o [[Elimina√ß√£o de Gauss]] e [[Decomposi√ß√£o LU]]\n\n\u003e [!INFO] M√©todos iterativos\n\u003e Exemplos de m√©todos eliminativos s√£o [[M√©todo de Jacobi]] e [[M√©todo de Gauss-Seidel]]\n\n\n# Refer√™ncias\n- S√©rgio Peters, \u0026 Julio Felipe Szeremeta. C√°lculo num√©rico computacional (2019).\n- Burden, R. L., Faires, J. D., \u0026 Burden, A. M. (2015). _Numerical analysis_. Cengage learning.","lastmodified":"2022-10-19T15:09:54.834727215Z","tags":null},"/vault/calculo-numerico/Teorema-de-Taylor":{"title":"Teorema de Taylor","content":"\nUma das ideias centrais da S√©rie de Taylor √© aproximar fun√ß√µes n√£o polinomais por fun√ß√µes polinomiais. \n\n\u003e [!INFO] O Teorema de Taylor\n\u003e Seja $k \\geq 1$ um n√∫mero inteiro e $f: \\mathbb{R} \\rightarrow \\mathbb{R}$ uma fun√ß√£o $k$ vezes diferenci√°vel em um ponto $a\\in \\mathbb{R}$. Ent√£o, exite uma fun√ß√£o $h_k: \\mathbb{R} \\rightarrow \\mathbb{R}$ tal que\n\u003e $$f(x) = f(a) + f'(a)(x-a) + \\frac{f''(a)}{2}(x-a)^2 + \\ldots + \\frac{f^{(k)}}{k!}(x - a)^k + h_k(x)(x-a)^k$$ \n\u003e com $\\displaystyle \\lim_{k \\rightarrow \\infty} h_k(x) = 0.$\n\nEm termos pr√°ticos, isso implica que a fun√ß√£o $f(x)$ pode ser aproximado pelo polin√¥mio de Taylor, na vizinhan√ßa de um ponto $a \\in \\mathbb{R}$\n\nPor exemplo, considere a fun√ß√£o $f(x) = cos(x)$. Na vizinhan√ßa de $a = 0$, tem-se:\n\n$$f(x) = cos(x) = 1 - \\frac{1}{2}x^2 + \\frac{1}{24}x^4 + \\ldots$$\nQuanto maior o n√∫mero de termos adicionados √† s√©rie, melhor √© a aproxima√ß√£o.\n\n\u003ciframe src=\"https://www.desmos.com/calculator/rp0vhqtcps?embed\" width=\"600\" height=\"500\" style=\"border: 1px solid #ccc\" frameborder=0\u003e\u003c/iframe\u003e\n\n\n# Refer√™ncias\n- V√≠deo do Canal 3Blue1Brown. S√©ries de Taylor - Cap√≠tulo 10, Ess√™ncia do C√°lculo. https://youtu.be/3d6DsjIBzJ4","lastmodified":"2022-10-19T15:09:54.834727215Z","tags":null},"/vault/calculo-numerico/Vis%C3%A3o-geral-de-c%C3%A1lculo-num%C3%A9rico":{"title":"C√°lculo num√©rico","content":"\n- O que √© C√°lculo Num√©rico\n\t- Solu√ß√£o de modelos matem√°ticos. \n- A ordem das parcelas altera a soma\n\t- [[Sistemas de numera√ß√£o]]\n\t- [[Convers√µes entre bases]]\n\t- [[N√∫meros reais versus representa√ß√£o digital]]\n- Solu√ß√£o de equa√ß√µes\n\t- [[M√©todo da biparti√ß√£o]]\n\t- [[M√©todo da falsa-posi√ß√£o]]\n\t- [[M√©todo de Newton para equa√ß√µes]]\n\t- [[M√©todo das secantes]]\n\t- [[Resolu√ß√£o de equa√ß√µes polinomais]]\n\t- [[M√©todo de Birge-Vietta]]\n\t- [[M√©todo de M√ºller]]\n- Solu√ß√£o de sistemas de equa√ß√µes\n\t- [[Solu√ß√£o de sistemas lineares]]\n\t\t- [[Elimina√ß√£o de Gauss]]\n\t\t- [[Decomposi√ß√£o LU]]\n\t\t- [[M√©todo de Jacobi]]\n\t\t- [[M√©todo de Gauss-Seidel]]\n\t\t- [[T√©cnicas de relaxa√ß√£o]]\n\t- Sistemas n√£o lineares\n\t\t- [[M√©todo de Newton para sistemas de equa√ß√µes]]\n\t\t- [[M√©todos de Quasi-Newton]]\n- [[Resolu√ß√£o num√©rica de valores de problemas iniciais]]\n\t- [[M√©todo de Euler]]\n\t- [[M√©todos de Runge-Kutta]]\n\t- [[Sistemas de equa√ß√µes diferenciais]]\n- Resolu√ß√£o num√©rica de integrais definidas\n\t- [[M√©todos de Newton-C√¥tes]]\n\t- [[M√©todos de Gauss-Legendre]]\n- Ajustamento de curvas\n\t- [[M√©todo dos m√≠nimos quadrados]]\n- Interpola√ß√£o polinomial\n\t- [[Exist√™ncia e unicidade do polin√¥mio interpolador]]\n\t- [[M√©todo de Lagrange]]\n\t- [[M√©todo de Gregory-Newton]]\n\t- [[Erros de truncamento em interpola√ß√£o]]\n\t- [[Splines c√∫bicas]]\n- [[Octave]]","lastmodified":"2022-10-19T15:09:54.834727215Z","tags":null},"/vault/estrutura-dados/%C3%81rvores":{"title":"√Årvores","content":"\n# Introdu√ß√£o\n\n√Årvores s√£o estruturas de dados n√£o lineares. Uma organiza√ß√£o n√£o linear √© mais rica do que uma organiza√ß√£o linear, em que h√° uma rela√ß√£o simples de predecessor ou sucessor entre dois objetos no conjunto. Em uma √°rvore, h√° rela√ß√µes **hier√°rquicas** com elementos sendo ancestrais ou descendentes de outro. \n\nUm exemplo √© relacionado √† organiza√ß√£o de um livro √© dado a seguir. \n\n[![](https://mermaid.ink/img/pako:eNp1kb1qwzAQx19F3JwYJHfyUCjN2ELA3SQPIpIbgyUZVSqUkIcJGTLlKfxivTg1udJGgxD_j5-EbgebYCxU8B71sGVvK-UZrif50n3G0LDl8pE964FL3MZzyn1gvPk_I0hG3MmUsiiKO94D6fufzOXqya85l7UdT-MRH1DwvzYlE9mTFoGKqy1uUEGhsy1-Q2e5JK0ZiurkrkXJ5VrH8YA_2t5-i_iUSuSS1lwDC3A2Ot0ZnM7uklaQttZZBRUejW117pMC5fcY1TmF-stvoEox2wXkwehkV51GnIOq1f0HqtZ0KcTX68Snwe-_AU-QnNk)](https://mermaid.live/edit#pako:eNp1kb1qwzAQx19F3JwYJHfyUCjN2ELA3SQPIpIbgyUZVSqUkIcJGTLlKfxivTg1udJGgxD_j5-EbgebYCxU8B71sGVvK-UZrif50n3G0LDl8pE964FL3MZzyn1gvPk_I0hG3MmUsiiKO94D6fufzOXqya85l7UdT-MRH1DwvzYlE9mTFoGKqy1uUEGhsy1-Q2e5JK0ZiurkrkXJ5VrH8YA_2t5-i_iUSuSS1lwDC3A2Ot0ZnM7uklaQttZZBRUejW117pMC5fcY1TmF-stvoEox2wXkwehkV51GnIOq1f0HqtZ0KcTX68Snwe-_AU-QnNk)\n\n## Defini√ß√µes e propriedades\n\n\u003e [!CITE] (Goodrich et al, 2014)\n\u003e Uma √°rvore $T$ √© um conjunto de n√≥s (que armazenam elementos) de forma que os n√≥s possuem rela√ß√£o de pai-filho da seguinte forma:\n\u003e\u003e -  Se $T$ √© n√£o vazia, ela cont√©m um n√≥ chamado **raiz**, que n√£o possui pai.\n\u003e\u003e - Cada n√≥ em $v \\in T$, que n√£o √© a raiz, possui um √∫nico pai $w \\in T$ (cada n√≥ com pai $w$ √© chamado de filho de $w$).\n\nNote que essa defini√ß√£o √© recursiva, de forma que uma √°rvore $T$ √© vazia ou consiste de uma raiz que possui um conjunto sub-√°rvores filhas.\n\n\u003e [!INFO] Outras defini√ß√µes\n\u003e - Dois n√≥s que s√£o filhos de um mesmo pai s√£o chamadas de irm√£os.\n\u003e - Um n√≥ √© chamado de **externo** se n√£o possui filhos (tamb√©m s√£o chamados de **folhas**.\n\u003e - Um n√≥ √© chamado de **interno** se possui pelo menos um filho.\n\u003e - Um n√≥ $u$ √© ancestral de $v$ se $u = v$ ou se $u$ √© ancestral do pai de $v$.\n\u003e - Um n√≥ $v$ √© descendente de um n√≥ $u$ se $u$ √© um ancestral de $v$.\n\u003e - Uma **aresta** em uma √°rvore $T$ √© um par de n√≥s $(u, v)$ tal que $u$ √© pai de $v$, ou vice-versa\n\u003e - Um **caminho** em uma √°rvore $T$ √© uma sequ√™ncia de n√≥s em $T$ de forma que quaisquer dois n√≥s consecutivos na sequ√™ncia formam uma aresta de $T$.\n\u003e - Uma √°rvore √© **ordenada** se existe uma rela√ß√£o de ordem linear entre os filhos de qualquer n√≥.\n\n### Profundidade e altura de uma √°rvore\n\n\u003e [!INFO]\n\u003e Seja $p$  um n√≥ da √°rvore. A profundidade de $p$ √© o n√∫mero de ancestrais que $p$ possui, com exce√ß√£o dele mesmo\n\n- Note que, pela defini√ß√£o, \n\t- se $p$ √© a raiz da √°rvore ent√£o a profundidade de $p$ √© zero; \n\t- sen√£o a profundidade de $p$ √© igual a profundidade do pai de $p$ mais um.\nCom isso, pode-se construir o seguinte algoritmo, que computa a profundidade de um n√≥ $p$.\n\n```python\ndef depth(p):\n\tif (isRoot(p)):\n\t\treturn 0\n\telse:\n\t\treturn 1 + depth(parent(p))\n```\n\nO algoritmo tem custo de pior caso $O(d_p)$ em que $d_p$ √© a profundidade do n√≥ $p$.\n\n\u003e [!INFO] Altura de um n√≥\n\u003e A altura de um n√≥ $p$ de uma √°rvore $T$:\n\u003e - √© igual a zero se $p$ √© folha da √°rvore;\n\u003e - caso contr√°rio, √© igual a um a mais do que a maior altura do seu maior filho.\n\n```python\ndef height(p):\n\tif (isLeaf(p)):\n\t\treturn 0\n\telse:\n\t\treturn 1 + max(height(p) for p in p.children())\n```\n\nO custo de pior caso do algoritmo para a altura √© $O(n)$ visto que, se chamado a partir da raiz da √°rvore, todos os n√≥s ser√£o percorridos e o custo para cada chamada da fun√ß√£o √© constante. \n\nRepare na ordem com que os n√≥s da √°rvore s√£o percorridos tanto no algoritmo para o c√°lculo da profundidade quanto da altura. Um tema importante em estruturas n√£o lineares √© como realizar o percurso nessas estruturas de forma eficiente. H√° alguns [[vault/estrutura-dados/Percursos em √°rvores|percursos em √°rvores]] cl√°ssicos como o percurso em [[vault/estrutura-dados/Percursos em √°rvores#^fa633f|pr√©-ordem]], [[vault/estrutura-dados/Percursos em √°rvores#^9628fb|p√≥s-ordem]] e em [[vault/estrutura-dados/Percursos em √°rvores#^bde67f |largura]].\n\n# Refer√™ncias\n- Goodrich, M. T., Tamassia, R., \u0026 Goldwasser, M. H. (2014). _Data structures and algorithms in Java_. John Wiley \u0026 Sons.","lastmodified":"2022-10-19T15:09:54.838726933Z","tags":null},"/vault/estrutura-dados/%C3%81rvores-B":{"title":"√Årvores B","content":"\n# √Årvores B\n\n- Diversos sistemas de bancos de dados utilizam √Årvores B (ou variantes) para armazenar as informa√ß·∫Ωos.\n- Generaliza√ß√£o de [[√Årvores bin√°rias de busca]].\n- √â uma √°rvore semi balanceada.\n- √â interessante para armazenar itens em mem√≥ria principal ou secund√°ria. \n\t- [[√Årvore AVL]] e [[√Årvores preto-e-vermelho]] n√£o s√£o adequadas para mem√≥ria secund√°ria\n- Objetivo: Minimizar n√∫mero de opera√ß√µes de movimenta√ß√£o de dados (escrita/leitura)\n- Foi criada para lidar com situa√ß√µes em que o √≠ndice possui um n√∫mero grandes de chaves, apenas uma pequena fra√ß√£o delas pode ser gerenciada de forma eficiente em mem√≥ria principal.\n- A organiza√ß√£o de √≠ndices utilizado uma √°rvore B permite busca, inser√ß√£o e remo√ß√£o em tempo $O(log_t n)$  onde $n$ √© o tamanho do √≠ndice e $t$ um par√¢metro a ser definido.\n\n\u003e Uma √°rvore B, $T$, possui as seguintes propriedades:\n\t\u003e\u003e Cada n√≥ $x$ armazena $x_n$ chaves $x_{k_1} \\leq x_{k_2} \\leq \\ldots \\leq x_{k_n}$.\n\t\u003e\u003e Cada n√≥ interno cont√©m $x_{n+1}$ refer√™ncias $x_{c_1}, x_{c_2}, \\ldots, x_{c_{n+1}}$ para seus filhos.\n\t\u003e\u003e As chaves $x_{k_i}$ delimitam os valores das chaves armazenadas em cada sub√°rvore. Seja $k_i$ uma chave armazenada na sub√°rvore com raiz $x_{c_i}$, ent√£o: $$k_1 \\leq x_{k_1} \\leq k_2 \\leq x_{k_2} \\leq \\ldots \\leq x_{k_{x_n}} \\leq k_{x_n + 1}.$$\n\t\u003e\u003e Todas as folhas possuem a mesma profundidade\n\t\u003e\u003e N√≥s possuem um n√∫mero m√°ximo e m√≠nimo de chaves que podem armazenar. Esses limitantes s√£o express√µes em fun√ß√µes de um par√¢metro $t \\geq 2$, denominado de grau m√≠nimo da √°rvore B. \n\t\u003e\u003e\u003e Cada n√≥ com exce√ß√£o da raiz possui pelo menos $t - 1$ chaves. Todo n√≥ interno com exce√ß√£o da raiz possui no m√≠nimo $t$ filhos. \n\t\u003e\u003e\u003e Todo n√≥ possui no m√°ximo $2t-1$ chaves. Todo n√≥ interno possui no m√°ximo $2t$ filhos. \n\n- A √°rvore B mais simples possui $t=2$. Cada n√≥ interno possui 2, 3 ou 4 filhos (ou seja, √© uma 2-3-4 √°rvore).\n\n![[vault/attachments/ArvoreBexemplo.excalidraw|900]]\n\n\n- O n√∫mero de acessos ao disco em uma √Årvore B √© proporcional a altura da √°rvore, para a maiora das opera√ß√µes\n\n- Teorema: \n\u003e Seja $n \\geq 1$, ent√£o para qualquer √°rvore B com $n$ chaves, altura $h$ e grau m√≠nimo $t \\geq 2$ tem-se $$h \\leq log_t \\frac{n+1}{2}.$$ Ou seja, a altura √© $O(log_t n)$ \n\n- Demonstra√ß√£o\n- A raiz da √°rvore cont√©m pelo menos uma chave e todos os demais n√≥s cont√©m pelo menos $t-1$ chaves. Ou seja, existem pelos menos:\n\t - $2$ n√≥s com profundidade $1$;\n\t - $2t$ n√≥s com profundidade $2$;\n\t - $2t^2$ n√≥s com profundidade 3;\n\t - ...\n\t - $2t^{(h-1)}$ n√≥s com profundidade $h$.\n - Ou seja, o n√∫mero de n√≥s $n$ satisfaz $$n \\geq 1 + (t-1)\\sum_{i=1}^h (2t^{(i-1)}) = 1 + 2(t-1)\\frac{(t^h-1)}{t-1}.$$ Portanto $n \\geq 2t^h - 1$, resolvendo para $h$ tem-se a prova do teorema.\n\n## Opera√ß√µes elementares em uma √°rvore B\n\nPara os algoritmos a seguir √© suposto:\n- node[i]: retorna a chave na posi√ß√£o $i$ presente em $node$. \n- node.n: retorna o n√∫mero de elementos em $node$.\n- O m√©todo node.is_leaf() responde se $node$ √© uma folha.\n- node.child[i]: returna a $i$-√©sima sub√°rvore enraizada em $node$.\n\n### Busca\n\nA busca em uma √°rvore B √© an√°loga a uma busca em uma [[√Årvores bin√°rias de busca|√Årvore bin√°ria de busca]]. Em cada n√≥, √© necess√°rio verificar qual a sub√°rvore que potencialmente cont√©m o elemento de interesse.\n\n```\nfind(key, node):\n\ti = 0\n\twhile i \u003c node.n and key \u003e node[i]:\n\t\ti = i + 1\n\tif i \u003c node.n and key == node[i]:\n\t\treturn node, i\n\telse if node.is_leaf():\n\t\treturn None\n\telse:\n\t\tfind(key, node.child[i])\t\n\t\n```\n\nA complexidade da busca √© proporcional a altura da √°rvore, portanto $O(log_t \\ n)$. Note que, quanto maior o grau m√≠nimo da √°rvore, $t$, menor o n√∫mero de chamadas recursivas. Por qu√™? #pergunta\n\nDo ponto de vista de gerenciamento de arquivos. Suponha que foi utilizado uma estrat√©gia de acesso indexado sequencial, mas o √≠ndice √© grande o suficiente para n√£o poder ser armazenado todo na mem√≥ria principal. Como uma √°rvore B pode ser utilizada eficientemente nessa situa√ß√£o? #pergunta [[Organiza√ß√£o de arquivos#Arquivo indexado sequencial]]\n\n### Inser√ß√£o\n\nO processo de inser√ß√£o √© relativamente mais sofisticado do que no caso de [[vault/estrutura-dados/√Årvores bin√°rias]]. Inicialmente, se busca pela folha onde ser√° realizada a inser√ß√£o. No entanto, n√£o se pode simplesmente criar um novo n√≥ para inserir o elemento, pois isso implicaria em uma viola√ß√£o das propriedades definidores de uma √°rvore B. Qual propriedade? #pergunta \n\nNesse caso, o objetivo √© inserir o elemento no pr√≥prio n√≥ folha, que pode estar cheio. Para lidar com tal situa√ß√£o, pode ser necess√°rio realizar uma opera√ß√£o de particionamento do n√≥ folha (*split*). \n\n#### Split\n\nUm n√≥ que est√° cheio, possui $2t-1$ chaves. A opera√ß√£o de *split* √© feita dividindo o n√≥ cheio em dois $x$ e $y$ com $t-1$ chaves cada. O elemento com a chave mediana, $node[t-1]$, √© \"promovido\" para o n√≥ pai, identificando o ponto de divis√£o entre os elementos de $x$ e $y$. Contudo, caso o n√≥ pai tamb√©m esteja cheio, √© necess√°rio realizar o *split* antes de inserir. Ou seja, a opera√ß√£o de *split* pode gerar uma rea√ß√£o em cadeia, at√© a raiz da √°rvore. \n\nUtilize o simulador https://www.cs.usfca.edu/~galles/visualization/BTree.html:\n1. Escolha a op√ß√£o Max. Degree = 4. Equivalente $t = 2$.\n2. Insira as chaves 10, 20 e 30, respectivamente. Note que uma nova inser√ß√£o implica em um *overflow* da raiz. Ou seja, ser√° necess√°ria uma opera√ß√£o de *split*.\n3. Insira a chave 0. Note que o n√≥ na posi√ß√£o $t-1 = 1$ foi promovido, marcando o ponto de separa√ß√£o entre as duas sub√°rvores geradas. \n4. Insira as chaves 2, 3 e 40 respectivamente. Com uma inser√ß√£o seguinte da chave 35, qual chave seria promovida e como ficariam os dois novos n√≥s gerados? #pergunta \n5. Insira a chave 35.\n6. Insira a chave 4 e a 50, respectivamente. Qual o estado final da √°rvore se for inserida a chave 55? #pergunta\n7. Insira a chave 55. \n\n#check (Cormen, pg 493)\n\u003e As with a binary search tree, we can insert a key into a B-tree in a single pass down the tree from the root to a leaf. To do so, we do not wait to find out whether we will actually need to split a full node in order to do the insertion. Instead, as we travel down the tree searching for the position where the new key belongs, we split each full node we come to along the way (including the leaf itself). Thus whenever we want to split a full node y, we are assured that its parent is not full.\n\n### Remo√ß√£o\n\nComo √© poss√≠vel remover elementos de n√≥s internos, e n√£o apenas de n√≥s folha, a opera√ß√£o de remo√ß√£o pode implicar na reorganiza√ß√£o de alguns elementos da √°rvore. Suponha que a busca pelo elemento a ser removido come√ßa no n√≥s raiz $x$\n\n1. Se a chave $k$ est√° em $x$ e $x$ √© um n√≥ folha. Remova $k$ de $x$.\n2. Se a chave $k$ est√° em $x$ e $x$ √© um n√≥ interno $x$:\n\t1. Se o filho $y$ que precede $k$ no n√≥ $x$ possui pelo menos $t$ chaves, encontre o predecessor $k'$ de $k$ na sub√°rvore cuja raiz √© $y$. Recursivamente remova $k'$ e substitua $k$ por $k'$ em $x$.\n\t2. Se $y$ possui menos de $t$ chaves, verifique se o filho $z$ que sucede $k$ em $x$. Se $z$ possuir pelo menos $t$ chaves, encontre o sucessor $k'$ de $k$ na sub√°rvore cuja raiz √© $z$. Recursivamente remova $k'$ e substitua $k$ por $k'$ em $x$.\n\t3. Caso ambos, $y$ e $z$, possuam $t-1$ chaves, fa√ßa uma jun√ß√£o (*merge*) de $z$  em $y$ ($k$ tamb√©m √© movido para $y$) e $y$ passa a conter $2t-1$ chaves. Ent√£o, destrua $z$ e recursivamente remove $k$ de $y$.\n3. Se a chave $k$ n√£o est√° presente em $x$ e $x$ √© um n√≥ interno $x$: Determine a raiz $x.c_i$ da sub√°rvore que (potencialmente) cont√©m $k$. Se $x.c_i$ possui apenas $t-1$ chaves, execute um dos passos a seguir para garantir que a busca continua em um n√≥ com pelo menos $t$ chaves. Ent√£o, continue recursivamente do filho apropriado de $x$\n\t1. Se $x.c_i$ possui apenas $t-1$ chaves mas possui um irm√£o imediato com $t$ chaves, mova uma chave de $x$ para $x.c_i$, mova a chave do irm√£o imediato de $x.c_i$ para $x$.\n\t2. Se $x.c_i$ e ambos os seus irm√£os possuem $t-1$ chaves, fa√ßa o *merge* de $x.c_i$ com um dos irm√£os (movendo uma chave de $x$ para o novo n√≥). \n\nConsidere o exemplo a seguir de [[2009Cormen_IntroductionToAlgorithms|Cormen et al. (2009)]] para uma √°rvore com $t = 3$.\n\n![[Pasted image 20220715163554.png]]\n\n![[Pasted image 20220715163604.png]]\n\nConsidere uma √°rvore com $n$ elementos. Em que tipo de n√≥ (folha ou interno), o ocorre o maior n√∫mero de remo√ß√µes? #pergunta\n\n## √Årvores B e gerenciamento de arquivos\n\nUma das motiva√ß√µes primordiais da proposi√ß√£o da estrutura de dados √Årvore B √© no contexto de gerencia de arquivos com acesso indexado sequencial. Nesse estrat√©gia, √© criado um √≠ndice auxiliar com a posi√ß√£o das chaves dos registros que est√£o armazenados em mem√≥ria secund√°ria. Quando o √≠ndice auxiliar pode ser armazenado completamente em mem√≥ria prim√°ria, h√° um grande ganho de efici√™ncia na opera√ß√£o de busca, em rela√ß√£o a ter que buscar em um arquivo em mem√≥ria secund√°ria. Por outro lado, pode n√£o ser poss√≠vel armazenar todo o √≠ndice em mem√≥ria prim√°ria. Nessa situa√ß√£o, pode ser interessante armazenar o √≠ndice em uma estrutura de √Årvore B. \n\nUma vantagem de se utilizar √°rvore B nesse caso √© a possibilidade de armazenar os n√≥s mais altos da √°rvore na mem√≥ria principal, minimizando o n√∫mero de requisi√ß√µes √† mem√≥ria secund√°ria. Al√©m disso, durante a busca, se for necess√°rio carregar novos dados em mem√≥ria, isso √© feito lendo um bloco de informa√ß√µes (e n√£o apenas um √∫nico valor, como seria no caso de outras [[vault/estrutura-dados/√Årvores bin√°rias]]).\n\nUma desvantagem dessa estrat√©gia √© a de que s√£o armazenadas, em cada n√≥, refer√™ncias para cada valor na mem√≥ria secund√°ria, al√©m do valor em si (os registros propriamente ditos). Isso reduz consideravelmente o n√∫mero de chaves que pode ser armazenadas na mem√≥ria principal, aumentando o n√∫mero de acessos √† mem√≥ria secund√°ria. Para reduzir essa desvantagem, podem ser utilizadas [[√Årvores B+]].\n\n\n## Compara√ß√µes com outras formas de organiza√ß√£o de √≠ndices\n\nDe acordo com o artigo original [[√Årvores B#^bf7c66]], algumas vantagens de se utilizar √Årvores B s√£o:\n- N√£o h√° degrada√ß√£o de performance se a taxa de ocupa√ß√£o do dispositivo de armazenamento for alta\n- A ordem natural das chaves √© mantida.\n\t- Permite processamentos de busca por predecessores, sucessores, busca por registros iniciando com em uma chave definida etc\n- Se buscas, inser√ß√µes e remo√ß√µes forem feitas em batches, o processamento √© muito eficiente, essencialmente processando o arquivo sequencialmente. Desde que seja feita uma ordena√ß√£o das requisi√ß√µes pela chave.\n\n# Refer√™ncias\n- INE 5408 - Estruturas de Dados - Aulas 6.6 e 6.7 - √Årvores-B, conceitos, algoritmos \u0026 exemplos. https://youtu.be/zkVGGbmjTH4\n- Bayer, Rudolf, and Edward McCreight. \"Organization and maintenance of large ordered indexes.\" Software pioneers. Springer, Berlin, Heidelberg, 2002. 245-262. ^bf7c66\n- [[1998Sedgewick_AlgorithmInCPart1-4|Algorithms in C. Parts 1-4 (Sedgewick. 1998)]]\n- [[2009Cormen_IntroductionToAlgorithms|Cormen et al. (2009)]]\n- https://www.geeksforgeeks.org/introduction-of-b-tree/","lastmodified":"2022-10-19T15:09:54.838726933Z","tags":null},"/vault/estrutura-dados/%C3%81rvores-bin%C3%A1rias":{"title":"√Årvores bin√°rias","content":"\n# √Årvores bin√°rias\n\n\u003e [!CITE] (Goodrich et al, 2013)\n\u003e Um √°rvore bin√°ria √© uma [[√°rvore]] ordenada em que:\n\u003e - Cada n√≥ possui no m√°ximo dois filhos.\n\u003e - Cada filho √© nomeado com filho da esquerda e filho da direita.\n\u003e - O filho da esquerda precede o da direita.\n\nUma √°rvore bin√°ria √© chamada de **pr√≥pria** se cada n√≥ tem zero ou dois filhos (caso contr√°rio a √°rvore √© chamada de **impr√≥pria**). Portanto, em uma √°rvore bin√°ria pr√≥pria, cada n√≥ interno possui dois filhos.\n\nTamb√©m, √© poss√≠vel definir uma √°rvore bin√°ria de forma recursiva.\n\u003e [!CITE] (Goodrich et al, 2013)\n\u003e Uma √°rvore bin√°ria $T$ √© vazia ou consiste de:\n\u003e - um n√≥ $r$, chamado de raiz da √°rvore $T$;\n\u003e - uma √°rvore bin√°ria (possivelmente vazia), chamada de sub√°rvore esquerda de $T$;\n\u003e - uma √°rvore bin√°ria (possivelmente vazia), chamada de sub√°rvore direita de $T$.\n\nUma outra defini√ß√£o que nos ser√° √∫til √© a de √°rvore completa.\n\u003e [!INFO]\n\u003e Uma √°rvore bin√°ria √© completa se em todos os seus n√≠veis, com poss√≠vel exce√ß√£o do √∫ltimo, est√£o completamente cheios e todos os n√≥s est√£o o mais √† esquerda poss√≠vel.\n\n^f23f12\n\n## Exemplos\n\n√Årvores bin√°rias podem ser utilizadas para representar opera√ß√µes aritm√©ticas. Por exemplo, a express√£o \"A*B+C*D-E\" pode ser representada pela √°rvore bin√°ria a seguir. \n\n[![](https://mermaid.ink/img/pako:eNpdj7EOwjAMRH_F8kibgY4ZkIDyBWUjDFZjaEWTViEZUNV_J02XKvbid7qTzjO2o2aU-HY0dXCvlYU4AoQ4QbGHG2xUJDJhOD4Oz01aIannjC9ZpNpHqqReIRNig3WxRMPOUK9juXn1KPQdG1Yo46nJfRQqu0QfBT82P9ui9C5wiWHS5LnuKf5kUL5o-PLyB1CmQQY)](https://mermaid.live/edit#pako:eNpdj7EOwjAMRH_F8kibgY4ZkIDyBWUjDFZjaEWTViEZUNV_J02XKvbid7qTzjO2o2aU-HY0dXCvlYU4AoQ4QbGHG2xUJDJhOD4Oz01aIannjC9ZpNpHqqReIRNig3WxRMPOUK9juXn1KPQdG1Yo46nJfRQqu0QfBT82P9ui9C5wiWHS5LnuKf5kUL5o-PLyB1CmQQY)\n\n- [[√Årvores de decis√£o]]\n- √Årvores de [[Branch-and-bound]]\n\n## Propriedades de uma √°rvore bin√°ria\n\n\u003e [!INFO]\n\u003e Seja T uma √°rvore bin√°ria completa com $n \u003e0$ n√≥s. Ent√£o $T$ possui altura $h$ m√≠nima.\n\n\u003e [!INFO]\n\u003e A altura de uma √°rvore bin√°ria completa $T$ com $n$ n√≥s √© $h = \\lfloor log\\ n \\rfloor$. \n- Pode-se mostrar tal propriedade utilizando indu√ß√£o.\n\t- Se $n = 1$, ent√£o $h = \\lfloor log\\ n \\rfloor = 0$, provando o caso base.\n\t- Para $n \u003e 1$, suponha que o resultado √© v√°lido para todas as √°rvores com $n-1$ n√≥s. Seja $T'$ a √°rvore obtida pela remo√ß√£o dos $k$ n√≥s do √∫ltimo n√≠vel de $T$. Logo $T'$ √© uma √°rvore cheia com $n' = n - k$ n√≥s. Pela hip√≥tese indutiva, $h(T') = \\lfloor log\\ n' \\rfloor$. Al√©m disso, $T'$ √© uma √°rvore cheia, tendo portando $n' = 2^{m+1}-1$ n√≥s, sendo $m$ a altura de $T'$. Ent√£o $$h(T) = 1 + h(T') = 1 + m = log\\ (n' + 1).$$\n\t- Mas $1 \\leq k \\leq n'+1$, portanto $\\lfloor log\\ (n' + 1) \\rfloor = \\lfloor log\\ (n' + k) \\rfloor \u003c log\\ (2n' + 2)$. Assim, $$h(T) = log\\ (n' + 1) = \\lfloor log\\ (n' + k) \\rfloor = \\lfloor log\\ (n) \\rfloor.$$\n\n## Percurso em-ordem em √°rvores bin√°rias\n\nAl√©m dos [[vault/estrutura-dados/Percursos em √°rvores|percursos em √°rvores]] j√° definidos, em √°rvores bin√°rias tamb√©m h√° o percurso em-ordem (ou ordem sim√©trica). Nesse percurso, √© visita da sub√°rvore esquerda, a raiz e a sub√°rvore direita, respectivamente.\n\n```python\ndef inorder(T, root):\n\tif (root):\n\t\tinorder(T, root.left)\n\t\tvisit(root)\n\t\tinorder(T, root.right)\n```\n\n## Implementa√ß√µes de √°rvore bin√°ria\n\n√â poss√≠vel implementar √°rvores bin√°rias utilizando uma estrutura encadeada, em que cada n√≥ √© possui refer√™ncias para o filho da esquerda e da direita respectivamente. \n\n\u003ciframe src=\"https://excalidraw.com/#json=HDqoj4NnCNbcTraYTnsmE,KhO4A-xOZ_MYLIO47iTFVA\" height=\"600\" width=\"600\" title=\"Binary tree linked implementation\"\u003e\u003c/iframe\u003e\n\nPara codificar tal solu√ß√£o √© poss√≠vel utilizar uma estrutura (ou classe) como a seguir:\n\n```python\nclass Node:\n\tdef __init__(self):\n\t\tself.value = None\n\t\tself.left = None\n\t\tself.right = None\n```\n\nOs algoritmos de busca, inser√ß√£o e remo√ß√£o frequentemente se aproveitam de outras propriedades como no caso de [[√Årvores bin√°rias de busca]].\n\nOutra op√ß√£o √© utilizar uma [[√Årvores bin√°rias implementadas em vetor|implementa√ß√£o em vetor]], que √© utilizada em situa√ß√µes mais espec√≠ficas, como na implementa√ß√£o de um [[Heap|heap]].\n\n# Refer√™ncias\n- Cormen, T. H., Leiserson, C. E., Rivest, R. L., \u0026 Stein, C. (2009). Introduction to Algorithms. third. _New York_.\n","lastmodified":"2022-10-19T15:09:54.838726933Z","tags":null},"/vault/estrutura-dados/%C3%81rvores-bin%C3%A1rias-implementadas-em-vetor":{"title":"√Årvores bin√°rias implementadas em vetor","content":"\n# Implementa√ßao em vetor para √°rvores bin√°rias\n\nConsidere uma [[√Årvores bin√°rias#^f23f12|√°rvore bin√°ria completa]] com $n$ n√≥s. Para uma implementa√ß√£o em vetor, assume-se que a raiz √© colocada na posi√ß√£o $0$ do vetor, para cada posi√ß√£o $i = 1, \\ldots, n-1$, tem-se:\n- $2i+1$: A posi√ß√£o do filho esquerdo do n√≥ na posi√ß√£o $i$.\n- $2i+2$: A posi√ß√£o do filho direito do n√≥ na posi√ß√£o $i$.\n\nPortanto, a √°rvore\n\n[![](https://mermaid.ink/img/pako:eNpNzjsOgzAQBNCrWFvDBVxECph86qTcZoWXj4QNMnYRIe4eYzfeafZJU8wB_aoZJIyOtkl8FVoR7y7q-iaaEm1Gk6BKdBltwqPEM0MlvEq80V6BCgw7Q7OOE46rgOAnNowg46t5oLB4BLRnrFLw6-dne5DeBa4gbJo8q5nieANyoGXn8w9dTjle)](https://mermaid.live/edit#pako:eNpNzjsOgzAQBNCrWFvDBVxECph86qTcZoWXj4QNMnYRIe4eYzfeafZJU8wB_aoZJIyOtkl8FVoR7y7q-iaaEm1Gk6BKdBltwqPEM0MlvEq80V6BCgw7Q7OOE46rgOAnNowg46t5oLB4BLRnrFLw6-dne5DeBa4gbJo8q5nieANyoGXn8w9dTjle)\n\nSeria representada no vetor:\n| 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| A   | B   | C   | D   | E   | F   | G   | H   | I    |\n\nNote que, com essa implementa√ß√£o, √© poss√≠vel obter o pai de um n√≥ na posi√ß√£o $i$ fazendo $p(i) = \\lfloor\\frac{i-1}{2}\\rfloor$, ou seja, com custo $O(1)$. \n\nEssa implementa√ß√£o de √°rvores em vetores podem ser utilizadas na implementa√ß√£o de [[Heap|heaps]].\n\n## Coment√°rios, observa√ß√µes e perguntas\n\n- Considere uma √°rvore completa com $d$ n√≠veis cheios, quantas posi√ß√µes precisariam ser alocadas no vetor para armazenar tal √°rvore? #pergunta \n- Qual a desvantagem de armazenar √°rvores n√£o completas em vetor, da forma apresentada? #pergunta \n- Como ficariam as express√µes de filhos da esquerda, direita e pai de um n√≥ na posi√ß√£o $i$ caso o vetor fosse indexado como o in√≠cio em 1? #pergunta\n- Como ficariam as express√µes de filhos e pai de um n√≥ na posi√ß√£o $i$ caso o vetor fosse utilizado para implementar uma √°rvore tern√°ria? #pergunta\n\n\n# Refer√™ncias\n- Cormen, T. H., Leiserson, C. E., Rivest, R. L., \u0026 Stein, C. (2022). _Introduction to algorithms_. MIT press.","lastmodified":"2022-10-19T15:09:54.838726933Z","tags":null},"/vault/estrutura-dados/Algoritmo-de-Huffman":{"title":"C√≥digos de Huffman","content":"\n\n# C√≥digos de Huffman\n\nC√≥digos de Huffman s√£o capazes de realizar compress√£o de dados sem perda de informa√ß√£o (*lossless*). Economias de 20 a 90% s√£o t√≠picas, dependendo do tipo de dado a ser comprimido.\n\nAqui, se considera um dado com uma s√©rie de caracteres. O algoritmo de Huffman utiliza uma tabela com a frequ√™ncia de cada caracter para construir uma forma √≥tima de representar cada caracter como uma *string* de *bits*.\n\n## Exemplo\n\nSuponha um arquivo de 100000 caracteres de dados que se deseja comprimir. √â observado que os caracteres no arquivo aparecem com uma certa frequ√™ncia e apenas seis caracteres diferentes aparecem. Para utilizar um c√≥digo de tamanho fixo, seriam necess√°rios 3 bits para cada caracter, mas tamb√©m √© poss√≠vel utilizar um c√≥digo de tamanho vari√°vel, como mostra a tabela.\n\n|                            | a   | b   | c   | d   | e    | f    |\n| -------------------------- | --- | --- | --- | --- | ---- | ---- |\n| Frequ√™ncia (em milhares)   | 45  | 13  | 12  | 16  | 9    | 5    |\n| C√≥digo de tamanho fixos    | 000 | 001 | 010 | 011 | 100  | 101  |\n| C√≥digo de tamanho vari√°vel | 0   | 101 | 100 | 111 | 1101 | 1100 |\n\nUtilizando um c√≥digo de tamanho fixo, seriam utilizados $3 \\cdot (45 + 13 + 12 + 16 + 9 + 5)\\cdot 10^3 = 300000$ bits. Mas utilizando o c√≥digo de tamanho vari√°vel proposto, seriam utilizados $(1 \\cdot 45 + 3 \\cdot 13 + 3 \\cdot 12 + 3 \\cdot 16 + 4 \\cdot 9 + 4 \\cdot 5) \\cdot 10^3 = 224000$ bits. Resultando numa economia de 66000 *bits* (aproximadamente 25%). Na verdade, essa √© uma forma √≥tima de representar esses dados. \n\n# C√≥digos de prefixo\n\nSer√£o considerados apenas c√≥digos tais que cada palavra-c√≥digo (*codeword*) n√£o √© prefixo de uma outra palavra-c√≥digo. C√≥digos de prefixo possuem a vantagem de simplificar a decodifica√ß√£o.\n\n## √Årvores de decodifica√ß√£o para o exemplo\n\n[![](https://mermaid.ink/img/pako:eNptkLsOgkAQRX9lM9WSaMKKmDiFiYrvUrtdipVdlChoEAoj_rsjEhqc6ibnninuC6KbsYBwyvX9zA6ByhjdlAvXdVi_P2GVW7GZ1Dj0wy4TFZtz33d-pI6tFPDBH0DGgntuA-pOayxlhGIQdhA5K3lE4TWoftBaay6GTgeQs5EGxahx6lbrbGWMfpeQtJMWxyH0ILV5qhND07y-PQXF2aZWAVI0Or8oUNmberosbvtnFgEWeWl7UN6NLmyQaFo0BYz19WHfH4grXGI)](https://mermaid.live/edit#pako:eNptkLsOgkAQRX9lM9WSaMKKmDiFiYrvUrtdipVdlChoEAoj_rsjEhqc6ibnninuC6KbsYBwyvX9zA6ByhjdlAvXdVi_P2GVW7GZ1Dj0wy4TFZtz33d-pI6tFPDBH0DGgntuA-pOayxlhGIQdhA5K3lE4TWoftBaay6GTgeQs5EGxahx6lbrbGWMfpeQtJMWxyH0ILV5qhND07y-PQXF2aZWAVI0Or8oUNmberosbvtnFgEWeWl7UN6NLmyQaFo0BYz19WHfH4grXGI)\n\n## Construindo uma √°rvore com o c√≥digo de Huffman\n\nSeja $C$ um conjunto de $n$ caracteres e a cada caracter $c \\in C$ est√° associado a uma frequ√™ncia *c.freq*.  O algoritmo a seguir constr√≥i uma √°rvore correspondendo ao melhor c√≥digo com uma l√≥gica *bottom-up.* Ele inicia com um conjunto de $|C|$ n√≥s folhas e realiza $|C|-1$ opera√ß√µes de jun√ß√£o para construir uma √°rvore. O algoritmo utiliza uma fila de prioridade (de m√≠nimo) de caracteres, com a prioridade sendo *c.freq*. O resultando de uma jun√ß√£o √© um novo objeto cuja a frequ√™ncia √© a soma dos dois operandos.\n\n```\nfunction huffman_tree(C)\n\tn = |C|\n\tQ = C\n\tfor i = 1 to n-1\n\t\tcrie um novo n√≥ z\n\t\tz.left = x = EXTRACT_MIN(Q)\n\t\tz.right = y = EXTRACT_MIN(Q)\n\t\tz.freq = x.freq + y.freq\n\t\tINSERT(Q, z)\n\treturn EXTRACT_MIN(Q)  // Raiz da √°rvore\n```\n\n### An√°lise do algoritmo\n\nAssumindo que a fila de prioridade seja implementada com um [[Heap]] de m√≠nimo, a constru√ß√£o do [[Heap]], para uma cadeia com $n$ caracteres pode ser feita em $O(log(n))$. O la√ßo de repeti√ß√£o executa $(n-1)$ vezes, como cada opera√ß√£o da [[Heap]] possui custo $O(log(n))$, o la√ßo contribui com $O(nlog(n))$ para o custo do algoritmo. √â poss√≠vel implement√°-lo em $O(n log (log(n)))$ utilizando uma [[√Årvore de Van Emde Boas]]. \n\n# Refer√™ncias\n\n- Cormen, T. H., Leiserson, C. E., Rivest, R. L., \u0026 Stein, C. (2009). Introduction to Algorithms. third. _New York_.","lastmodified":"2022-10-19T15:09:54.834727215Z","tags":null},"/vault/estrutura-dados/An%C3%A1lise-de-algoritmos":{"title":"An√°lise de algoritmos","content":"\n\n# An√°lise de algoritmos\n\n## O que √© complexidade computacional?\n\nA complexidade computacional de um algoritmo √© uma medida da quantidade de recursos computacionais utilizados. Esses recursos s√£o: Tempo e espa√ßo (mem√≥ria).\n\nO tempo de execu√ß√£o √© determinado por dois fatores:\n- O custo de execu√ß√£o de cada comando.\n\t- Depende do computador, compilador, linguagens de programa√ß√£o, sistema operacional entre outros.\n- A frequ√™ncia de execu√ß√£o de cada comando.\n\t- Depende do algoritmo e da entrada.\n\nA separa√ß√£o desses dois fatores permite uma an√°lise de algoritmos independente da plataforma computacional. \n\nOpera√ß√µes elementares:\n- Opera√ß√£o com n√∫mero de passos constante.\n\n### Exemplos\n\nQual a quantidade de mem√≥ria e o n√∫mero de opera√ß√µes utilizados pela fun√ß√£o a seguir, que recebe uma lista $L$? #pergunta \n\n```\nfunction count_even(L):\n\tcount = 0\n\tfor x in L:\n\t\tif x % 2 == 0:\n\t\t\tcount = count+1\n\treturn count\t\n```\n\nO que acontece com a mem√≥ria utilizada e o n√∫mero de opera√ß√µes conforme o tamanho da lista $L$ varia? #pergunta \n\n\u003e A an√°lise de complexidade de algoritmos busca caracterizar a quantidade de mem√≥ria e o n√∫mero de opera√ß√µes conforme o tamanho da entrada aumenta. \n\nUm outro exemplo √© o algoritmo a seguir.\n```\n# Considera a lista L indexada a partir do zero\nfunction f(L):\n\ti = 0\n\tn = len(L)\n\twhile i \u003c n/2:\n\t\tL[i], L[n-i-1] = L[n-i-1], L[i]\n\t\ti = i+1\n```\n\n- O que o algoritmo realiza? #pergunta \n\t- Inverte a lista $L$.\n- O algoritmo executa as mesmas opera√ß√µes para qualquer lista de tamanho $n$. Cada passo executado corresponde √† troca de posi√ß√£o entre dois elementos da lista. Ou seja, cada passo corresponde √† execu√ß√£o de uma itera√ß√£o do la√ßo. Al√©m disso, s√£o executados $n/2$ passos. \n\n#### Soma e produto de matrizes\n\nConsidere duas matrizes $A=(a_{ij})$ e $B=(b_{ij})$, ambas com dimens√£o $n \\times n$. A obten√ß√£o da matriz soma $C_{ij}$ pode ser realizada pelo seguinte algoritmo.\n```python\nfor i = 1, ..., n\n\tfor j = 1, ..., n\n\t\tc[i, j] = a[i, j] + b[i, j]\n```\n\nCada passo do algoritmo corresponde √† execu√ß√£o de uma soma $a_{ij} + b_{ij}$. Quantas vezes essa soma ser√° realizada? #pergunta \n\nPara a obten√ß√£o da matriz produto $\\displaystyle D_{ij} = \\sum_{1\\leq k \\leq n}a_{ik}b_{kj}$\n```python\nfor i = 1, ..., n\n\tfor j = 1, ..., n\n\t\tc[i, j] = 0\n\t\tfor k = 1, ..., n\n\t\t\tc[i, j] = c[i, j] + a[i, k]*b[k, j]\n```\n\nO comando mais executado no algoritmo √© a linha $c[i, j] = c[i, j] + a[i, k]*b[k, j]$. Quantas vezes ela √© executada? #pergunta\n\n## Nota√ß√£o Big-O\n\n\u003e A nota√ß√£o Big-O (Grande O) descreve matematicamente como o uso de recurso varia em rela√ß√£o √†s vari√°veis de entrada.\n\n\n### Alguma regras\n\n- Ignorar as constantes. Termos de ordem menor s√£o relevantes apenas para entradas pequenas. \n\n#### Alguns exemplos $O(n)$\n- $O(a + n)$ = $O(n)$ se $a$ √© constante\n```\nfunction count_even(L):\n\tcount = 0\n\tfor x in L:\n\t\tif x % 2 == 0:\n\t\t\tcount = count+1\n\treturn count\t\n```\n\n- $O(n + n) = O(2n) = O(n)$\n```\n\tfunction min_max1(L):\n\t\tsmall = +infinity\n\t\tbig = -infinity\n\t\tfor x in L:\n\t\t\tsmall = min(small, x)\n\t\tfor x in L:\n\t\t\tbig = max(big, x)\n\t\treturn small, big\n```\n\n```\n\tfunction min_max1(L):\n\t\tsmall = +infinity\n\t\tbig = -infinity\n\t\tfor x in L:\n\t\t\tsmall = min(small, x)\n\t\t\tbig = max(big, x)\n\t\treturn small, big\n```\n\n\n#### Comportamento assint√≥tico\n- Ignorar termos de ordem menor. Termos de ordem menor s√£o relevantes apenas para entradas pequenas. Estamos interessados em casos com entradas grandes ($n \\rightarrow \\infty$). \n\t- Por qu√™? #pergunta \n\n\n## Complexidade de pior caso\n\nH√° algoritmos em que o n√∫mero de opera√ß√µes executadas depende da entrada. \n\n```\nfunction busca(x, v):\n\ti = 0\n\twhile i \u003c n:\n\t\tif x == v[i]\n\t\t\treturn True\n\t\ti = i + 1\n\treturn False\n```\n\nNesses casos, frequentemente, o interesse est√° na complexidade de pior caso, isto √©, o caso que est√° relacionado com o maior n√∫mero de opera√ß√µes. Outro caso importante √© a an√°lise de caso m√©dio, isto √©, em determinar, na m√©dia, qual a complexidade do algoritmo. Essa an√°lise pode ser bastante sofisiticada e, em geral, est√° fora do escopo deste material.\n\n## Algumas classes de complexidade\n\n### Ordem de complexidade linear, $O(n)$\n\n```\nfunction busca(x, v):\n\ti = 0\n\twhile i \u003c n:\n\t\tif x == v[i]\n\t\t\treturn True\n\t\ti = i + 1\n\treturn False\n```\n\n### Ordem de complexidade quadr√°tica, $O(n^2)$\nSupondo que as listas $va$ e $vb$ possuem $n$ elementos.\n\n```\nfunction busca(va, vb):\n\tfor x in va:\n\t\tfor y in vb:\n\t\t\tif x == y:\n\t\t\t\treturn True\n\treturn False\n```\n\n### Ordem de complexidade logar√≠timica, $O(log\\ n)$\n\nQuantas vezes √© necess√°rio dividir um n√∫mero positivo $n \u003e 0$ pela metade para chegar √† unidade?\n\n```\nfunction divisoes(n):\n\ti = 0\n\twhile n != 1:\n\t\tn = n//2\n\t\ti = i+1\n\treturn i\n```\n\n### Compara√ß√£o entre classes\n\nOs gr√°ficos a seguir apresentam uma compara√ß√£o visual entre as classes. No eixo horizontal est√° o tamanho do problema e no eixo vertical o custo (ambos em escala arbitr√°ria).\n\n![[/vault/estrutura-dados/attachments/Pasted image 20220419152228.png|500]]\n\n![[/vault/estrutura-dados/attachments/Pasted image 20220419152332.png|500]]\n\n![[vault/estrutura-dados/attachments/Pasted image 20220419152407.png | 500]]\n\n# Refer√™ncias e outros materiais\n- Complexidade de Algoritmos I - No√ß√£o Intuitiva. Canal do Youtube: Programa√ß√£o Din√¢mica. https://youtu.be/KVlGx-9CuO4\n- Nota√ß√£o do O Grande - Complexidade de Algoritmos II. Canal do Youtube: Programa√ß√£o Din√¢mica. https://youtu.be/UQzCFkRbIrE\n- [[2011Sedgewick_Algorithms|Algorithms (Sedgewick e Wayne. 2011)]]\n- Big O Notation. Canal do Youtube Hacker Hank. https://www.youtube.com/watch?v=v4cd1O4zkGw\n- J. Szwarcfiter e L. Markenzon (1994). Estruturas de dados e seus algoritmos (2a Edi√ß√£o). \n","lastmodified":"2022-10-19T15:09:54.834727215Z","tags":null},"/vault/estrutura-dados/Estruturas-de-dados-para-grafos":{"title":"Estruturas de dados para grafos","content":"\n# Introdu√ß√£o\n\nExistem diversas formas de representar um grafo computacionalmente. Duas formas consideradas cl√°ssicas s√£o (i) Lista de adjac√™ncias e (ii) Matriz de adjac√™ncias. \n\n\n## Lista de adjac√™ncias\n\n\u003e [!INFO] Lista de adjac√™ncias\n\u003e - Para cada v√©rtice $v \\in V$, h√° uma cole√ß√£o $I(v)$ de todos os v√©rtices incidentes em $v$. Tradicionalmente, $I(v)$ √© uma lista.\n\u003e - Para grafos direcionados pode se manter listas separadas de entrada ($I_{in}(v)$) e sa√≠da do n√≥ ($I_{out}(v)$).\n\u003e - A cole√ß√£o $V$ pode ser mantida em uma lista.\n\n![[attachments/Pasted image 20220920121758.png]]\n\n## Matriz de adjac√™ncias\n\n\u003e [!INFO] Matriz de adjac√™ncias\n\u003e - Utiliza uma matriz $n$ por $n$, $A$, para manter informa√ß√µes sobre as arestas.\n\u003e - Cada c√©lula $A[i, j]$ mant√©m uma refer√™ncia para a aresta $(u, v)$ em que $u$ √© o v√©rtice com √≠ndice $i$ e $v$ √© o v√©rtice com √≠ndice $j$.\n\n![[attachments/Pasted image 20220920121810.png]]\n\n# Compara√ß√£o entre as implementa√ß√µes\n\n- Na lista de adjac√™ncias √© poss√≠vel percorrer todos os n√≥s adjacentes a outro n√≥, $v$, em tempo $O(grau(v))$\n- A representa√ß√£o em matriz de adjac√™ncias permite acessar qualquer aresta com custo $O(1)$.\n- O espa√ßo adicional utilizado pela matriz de adjac√™ncias √© $O(n^2)$ enquanto que na lista de adjac√™ncias √© $O(n + m)$. Portanto, para grafos esparsos (poucas arestas ou arcos) o lista de adjac√™ncias √© vantajosa.","lastmodified":"2022-10-19T15:09:54.834727215Z","tags":null},"/vault/estrutura-dados/Grafos":{"title":"Grafos","content":"\n# Introdu√ß√£o e defini√ß√µes\n\nProblemas envolvendo grafos emergem em diversas √°reas da computa√ß√£o. Por isso, estruturas de dados e algoritmos para lidar com tais situa√ß√µes s√£o fundamentais. \n\n\u003e [!INFO]\n\u003e Um grafo $G = (V, E)$ √© composto por um conjunto de v√©rtices $V$ e um conjunto de arestas $E$. Os v√©rtices s√£o unidades (elementos ou entidades) e arestas indicam rela√ß√µes (liga√ß√µes ou conex√µes) entre v√©rtices, $E = \\lbrace \\lbrace i, j \\rbrace : i, j \\in V \\rbrace$.\n\n- Exemplos:\n\t- Fronteiras entre pa√≠ses\n\t- Colabora√ß√£o entre pesquisadores\n\t- Rela√ß√µes em uma rede social\n\t- Mapa de uma cidade: v√©rtices s√£o cruzamentos\n\t- Rede de distribui√ß√£o de energia\n\n\n![](https://mermaid.ink/img/pako:eNqNU0tuwjAQvUo0a3KB7AqUripVou2GdDGNB2LJsenERmoRR-quN-BidX7QxAGaSPHMvDfPlvNmD5kRBAlsGLd59DxPdeSfKWMpVRTHcfTgJGpcrJo1WjDqjEp8C4hLx1JjQRcUgvIrafpypEJkZpQp3iWufHD8qaJwtydiFxSnRsmd7_Pr8Xs32oaMG4cyAO54Q9rKkXO-sDt3nGi3oP5GfezCMfukWS5Ve5ed1rXmmn6NUF3Y_wQGV3EGaomB2v2HQ2F4UO3-YFNuOSNIl40Z4pQGJmqtGJquy_4at0G6b_XCBAriAqXwvt9XSAo2Jy8CiQ8FrdEpm0KqD56Kzprlp84gsexoAm4r0NJcop-YApI1qtJXSUhr-LGZpXqkDr9QOBIv)\n\n\u003e [!INFO] \n\u003e Um grafo √© valorado quando um peso (ou valor) √© associado a cada aresta. Ou seja, $G = (V, E, w)$ em que $V$ e $E$ s√£o os conjuntos de v√©rtices e arestas respectivamente e $w: e \\in E \\rightarrow \\mathbb{R}$ √© uma fun√ß√£o que mapeia um aresta no seu peso correspondente. \n\n- Exemplos de situa√ß√µes com grafos ponderados\n\t- Taxas de importa√ß√£o/exporta√ß√£o\n\t- Dist√¢ncias no mapa de uma cidade\n\n\u003e [!INFO]\n\u003e Um grafo $G = (V, E)$ √© chamado de orientado (ou direcionado) se $E$ for formado por pares ordenados, $E = \\lbrace(i, j): i, j \\in V\\rbrace$. Ou seja, as liga√ß√µes entre os v√©rtices possuem dire√ß√£o. Cada liga√ß√£o √© chamada de arco.   \n\n- Exemplos de grafos direcionados\n\t- √Årvore geneal√≥gica\n\t- Heran√ßa em orienta√ß√£o a objetos\n\t- Malha vi√°ria (com as dire√ß√µes das rodovias)\n\n![](https://mermaid.ink/img/pako:eNptkU1PwzAMhv9K5BOI9Q9EXBBjEoeddkOVkJt4ndV8QD40weh_Jy1rGR25xH4cv3pjn0B5TSBBGYxxzdgGtLUT5Tw4tmjE_VdViXVW3TXdcDxc0xdqAv7BUtyxSwJbWuJdCuxa0ZLTFC6LQ0vcoi3hze2iYDHRBEfbo73TDxCzaEPYPXrjw1yIR7ZTY0nfM6puyvtLveFjs141eI_8Sc9uQ5RmrNA9Yfq3fxzBr6HGeyM4vh7Z6BmG7Ba904EVWAoWWZe9jCo1pANZqkGWUNMes0k11K4vTzEnv_twCmQKmVaQ33SZz3mTIPdoYqGkOfmwPe96uPpvoweZfg)\n\n\u003e [!INFO] O grau de um v√©rtice\n\u003e - O **grau** de um v√©rtice $v$, $d_v$, √© definido como a quantidade de arestas que se conectam com $v$. Em um grafo direcionado, pode-se definir:\n\u003e - O grau de sa√≠da de um v√©rtice $d_v^+$ como o n√∫mero de arcos que est√£o saindo de $v$.\n\u003e - O grau de entrada de um v√©rtice $d_v^-$ como o n√∫mero de arcos que chegam em $v$.\n\n\u003e [!INFO] Grafo completo\n\u003e \n\u003e Um grafo √© chamado de completo $G=(V, E)$  se $E = V \\times V$.\n\n\u003e [!HINT] Soma dos graus dos v√©rtices\n\u003e \n\u003e Um resultado √∫til para an√°lise de algoritmos √© o seguinte: A soma dos graus de todos os v√©rtices de um grafo \n\u003e $$\\sum_{v \\in V} d_v = 2|E|.$$\n\u003e No caso de grafos direcionados tem-se que\n\u003e $$\\sum_{v \\in V} d_v^+ = \\sum_{v \\in V} d_v^- = |E|.$$\n\n## O tipo abstrato de dados grafo\n\nAlgumas opera√ß√µes frequentes para o tipo abstrato de dados grafo $G$ s√£o as seguintes:\n- G.getVertices(): Retorna uma cole√ß√£o com os v√©rtices de $G$.\n- G.getArestas(): Retorna uma cole√ß√£o com as arestas de $G$.\n- G.getAdjacentes(v): Retorna uma cole√ß√£o com os v√©rtices adjacentes ao v√©rtice $v$. \n\t- Em um grafo direcionado, pode-se definir fun√ß√µes para coletar os v√©rtices que s√£o pontos de chegada e sa√≠da para $v$, respectivamente.\n- G.getDegree(v): Retorna o grau do v√©rtice $v$.\n- e.getOposto(v): Retorna o v√©rtice oposto a $v$ na aresta $e$.\n\nDurante a implementa√ß√£o o custo de cada opera√ß√£o depende das [[Estruturas de dados para grafos|estruturas de dados utilizadas para representar o grafo]]. \n\n# Percursos em grafos\n- Busca em largura\n- Busca em profundidade\n\n# Refer√™ncias\n- Cormen, T. H., Leiserson, C. E., Rivest, R. L., \u0026 Stein, C. (2009). Introduction to Algorithms. third. _New York_.\n- Sedgewick, R., \u0026 Wayne, K. (2014). _Algorithms_. Addison-Wesley Professional.\n- Goodrich, M. T., Tamassia, R., \u0026 Goldwasser, M. H. (2014). _Data structures and algorithms in Java_. John Wiley \u0026 Sons.\n- Notas de aula do Prof. Rafael Santiago. http://www.inf.ufsc.br/~r.santiago","lastmodified":"2022-10-19T15:09:54.834727215Z","tags":null},"/vault/estrutura-dados/Heaps":{"title":"Heaps","content":"\numa aplica√ß√£o de heaps √© no \n\n[[vault/estrutura-dados/Algoritmo de Huffman]] para compress√£o","lastmodified":"2022-10-19T15:09:54.834727215Z","tags":null},"/vault/estrutura-dados/Percursos-em-%C3%A1rvores":{"title":"Percursos em √°rvores","content":"\n# Percursos em √°rvores\n\nAs principais estrat√©gias para se percorrer uma √°rvore s√£o: percurso em pr√©-ordem, percurso em p√≥s-ordem e percurso em largura. Dependendo da tarefa a ser realizada, um percurso pode ser mais adequado que outro, facilitando a implementa√ß√£o. Todos os algoritmos implementados a seguir possuem custo $O(n)$, sendo $n$ o n√∫mero de n√≥s da √°rvore. Tente entender o porqu√™.\n\n## Percurso em pr√©-ordem\n\n^fa633f\n\nNo percurso em pr√©-ordem, a raiz da √°rvore √© visitado primeiro, ent√£o s√£o visitadas todas as sub√°rvores filhas da raiz s√£o visitadas recursivamente (tamb√©m em pr√©-ordem). Caso a √°rvore seja ordenada, ent√£o as sub√°rvore s√£o visitadas de acordo com a propriedade de ordena√ß√£o definida.\n\n```python\ndef preorder(T):\n\tvisit(T.root)\n\tfor c in T.children():\n\t\tpreorder(c)\n```\n\nConsidere o exemplo a seguir com a √°rvore enraizada em $A$. \n\n![](https://mermaid.ink/img/pako:eNpV0M0OgjAMB_BXWXqGF9jBRByK-IGJHndpWBWiAzLHwRDe3bHswHrq799e2gnqXhFweBkcGvYQsmOutixNNyxbY8fWEpHyoMxrH-kQJLyKSMdIZVDhdVrjHEa51yXSNVIVVHndFkACmozGVrk7pyWRYBvSJIG7VqF5S5Dd7PZwtP3919XArRkpgXFQaEm06N6jgT_x86X5D4QzSz4)\nO percurso em pr√©-ordem visita os n√≥s na seguinte ordem: \n- A, B, F, G, C, D, H, K, L, I, J, E, M, N, O, P\n\n\n## Percurso em p√≥s-ordem\n\n^9628fb\n\nNo percurso em p√≥s-ordem, as sub√°rvores da raiz s√£o percorridas recursivamente (em p√≥s-ordem) antes da raiz. Caso a √°rvore seja ordenada, ent√£o as sub√°rvore s√£o visitadas de acordo com a propriedade de ordena√ß√£o definida.\n\n```python\ndef postorder(T):\t\n\tfor c in T.children():\n\t\tpostorder(c)\n\tvisit(T.root)\n```\n\nConsidere o exemplo a seguir com a √°rvore enraizada em $A$. \n\n![](https://mermaid.ink/img/pako:eNpV0M0OgjAMB_BXWXqGF9jBRByK-IGJHndpWBWiAzLHwRDe3bHswHrq799e2gnqXhFweBkcGvYQsmOutixNNyxbY8fWEpHyoMxrH-kQJLyKSMdIZVDhdVrjHEa51yXSNVIVVHndFkACmozGVrk7pyWRYBvSJIG7VqF5S5Dd7PZwtP3919XArRkpgXFQaEm06N6jgT_x86X5D4QzSz4)\n\nO percurso em p√≥s-ordem visita os n√≥s na seguinte ordem: \n- F, G, B, C, K, L, H, I, J, D, M, N, P, O, E, A\n\n## Percurso em largura (*breadth-first search*)\n\n^bde67f\n\nNo percurso em largura, todos os n√≥s com profundidade $p$ s√£o visitados antes daqueles com profundidade $d+1$.\n\n```python\ndef bfs(T):\n\tQ = Queue()\n\tQ.push(T.root)\n\twhile(not Q.is_empty()):\n\t\tp = Q.deque()\n\t\tvisit(p)\n\t\tfor c in T.children(p):\n\t\t\tQ.push(c)\n```\n\nConsidere o exemplo a seguir com a √°rvore enraizada em $A$. \n\n![](https://mermaid.ink/img/pako:eNpV0M0OgjAMB_BXWXqGF9jBRByK-IGJHndpWBWiAzLHwRDe3bHswHrq799e2gnqXhFweBkcGvYQsmOutixNNyxbY8fWEpHyoMxrH-kQJLyKSMdIZVDhdVrjHEa51yXSNVIVVHndFkACmozGVrk7pyWRYBvSJIG7VqF5S5Dd7PZwtP3919XArRkpgXFQaEm06N6jgT_x86X5D4QzSz4)\n\nO percurso em largura visita os n√≥s na seguinte ordem: \n- A, B, C, D, E, F, G, H, I, J, M, N, O, K, L, P\n\n\n## Aplica√ß√µes de percursos em √°rvores\n\n- Contabilizar a mem√≥ria ocupada pelos arquivos em um diret√≥rio (composto de arquivos que podem ser outros diret√≥rios). \n- Copiar uma √°rvore.\n- Deletar uma √°rvore\n\n\n# Refer√™ncias\n- Goodrich, M. T., Tamassia, R., \u0026 Goldwasser, M. H. (2014). _Data structures and algorithms in Java_. John Wiley \u0026 Sons.","lastmodified":"2022-10-19T15:09:54.834727215Z","tags":null},"/vault/estrutura-dados/Recurs%C3%A3o":{"title":"Recurs√£o","content":"\n# Introdu√ß√£o\n\u003e To iterate is human, to recurse is divine (Laurence Peter Deutsch)\n\n- Recurs√£o √© um conceito gen√©rico presente em v√°rias disciplinas e na pr√≥pria natureza.\n- Uma entidade (ou conceito) √© recursivo quando √© composto por inst√¢ncias menores dele mesmo (ou similares). \n- Alguns exemplo (Figura retirada de [[2017Sanchez_IntroductionRecursiveProgramming|Introduction to recursive programming. Sanchez (2019)]]): \n\t- ![[vault/estrutura-dados/attachments/Pasted image 20220412150007.png]]\n\t- H√° tamb√©m entidades menos concretas que s√£o identificadas como recursivas. Por exemplo a sequ√™ncia $(s_1, s_2, \\ldots, s_n)$ definida de acordo com $$s_n = s_{n-1} + s_{n-2}.$$ A f√≥rmula define que o $n$-√©simo termo da sequ√™ncia √© dado pela soma dos dois anteriores. Portanto, os termos da sequ√™ncia s√£o definidos a partir deles mesmos. Note que n√£o √© apenas uma sequ√™ncia que √© definida a partir da f√≥rmula. \n\t\t- Quais s√£o exemplos de sequ√™ncias que s√£o definidas pelas f√≥rmula apresentada #pergunta \n\t\t\t- Tipicamente, se utiliza $s_1 = s_2 = 1$, o que define a [[Sequ√™ncia de Fibonacci]].\n\n## Alguns exemplos\n- A [[Sequ√™ncia de Fibonacci]] pode ser entendida como uma fun√ß√£o definida da seguinte forma. $$F(n) = \\begin{cases}1, \u0026 n = 1, \\\\ 1, \u0026 n = 2,\\\\ F(n-1) + F(n-2), \u0026 n \\geq 3.\\end{cases}$$\n\t- Note a exist√™ncia de dois tipos de express√£o:\n\t\t- Casos-base: Casos em que o resultado pode ser obtido de forma trivial ($n=1$ e $n=2$).\n\t\t- Casos recursivos: Casos em que h√° depend√™ncia de inst√¢ncias menores (mais simples) da pr√≥pria fun√ß√£o $(n \\geq 3)$.\n\t\t- Em uma defini√ß√£o recursiva, √© necess√°rio ter pelo menos um caso-base? #pergunta \n\n```python\n def fib(n):\n    if n == 1 or n == 2:\n        return 1\n    else:\n        return fib(n-1) + fib(n-2)\n```\n\n- Outra fun√ß√£o intrinsicamente recursiva √© a fatorial de um n√∫mero positivo $n$. $$n! = 1 \\cdot 2 \\cdot 3 \\ldots \\cdot n.$$ No entanto, n√£o h√° uma depend√™ncia expl√≠cita da pr√≥pria fun√ß√£o fatorial. Para express√°-la de forma recursiva √© necess√°rio observar que $n! = (n-1)! \\cdot n$. Com isso, tem-se: $$n! = \\begin{cases} 1, \u0026 n = 1, \\\\ (n-1)! \\cdot n \u0026 n \\geq 2. \\end{cases}$$\n\t- Qual o caso-base e qual o caso recursivo da fun√ß√£o fatorial? #pergunta \n\n```python\ndef fat(n):\n    if n == 0:\n        return 1\n    else:\n        return fat(n-1)*n\n```\n\n- De forma similar, o problema de se calcular a soma dos $n$ primeiros n√∫meros positivos pode ser formulado de forma recursiva. Uma fun√ß√£o que representa a solu√ß√£o do problema √© $$S(n) = 1 + 2 + \\ldots + n.$$ Novamente, n√£o √© direta a defini√ß√£o recursiva de $S$. √â necess√°rio notar que $$S(n) = S(n-1) + n.$$\n\t- Para esse problema, como pode ser escrita a fun√ß√£o recursiva? Identificando o caso-base e o caso recursivo #pergunta \n\n## Desenvolvendo uma solu√ß√£o recursiva*\n\nO desenvolvimento de solu√ß√µes recursivas para um problema depende da defini√ß√£o do(s) caso(s)-base e do(s) caso(s) recursivos. Em geral, o primeiro passo √© definir casos-base e o maior desafio est√° em descrever os casos recursivos. Para isso, √© necess√°rio entender dois conceitos importantes:\n1. Decomposi√ß√£o do problema\n2. Indu√ß√£o\n\n### Decomposi√ß√£o de um problema\n\nA decomposi√ß√£o √© um conceito importante n√£o apenas no conceito de recurs√£o. Trata-se da ideia de quebrar problemas complexos em problemas menores (mais simples) que sejam mais f√°ceis de expressar, computar ou resolver. No contexto de recurs√£o, a decomposi√ß√£o de um problema consiste em quebr√°-lo em subproblemas, alguns similares ao original. Com isso, a solu√ß√£o do problema original passa a consistir em resolver e combinar as solu√ß√µes do subproblemas. √â importante observar que a decomposi√ß√£o em subproblemas deve aproximar o problema original do(s) caso(s) base. \n\n- Considere o problema de encontrar a soma dos $n$ primeiros n√∫meros positivos: $S(n) = 1 + 2 + \\ldots + n$. Enquanto o caso base √© $S(1) = 1$, √© poss√≠vel decompor o problema de diversas formas para definir os casos recursivas. \n\t- Uma possibilidade √© reduzir $n$ em apenas uma unidade. Nesse caso, o objetivo seria definir $S(n)$ em fun√ß√£o de $S(n-1)$. \n\t\t- Qual seria uma outra possibilidade? #desafio\n\n- Considere o problema de computar a soma dos elementos em uma lista $L = [a_0, a_1, \\ldots, a_{n-1}]$, $S(L) = \\sum_{i=0}^{n-1}a_i$\n\t- O problema pode ser decomposto diminuindo o seu tamanho em uma unidade $$S(L) = \\begin{cases}0, \u0026 n = 0,\\\\ S(L[0:n-1]) + a_{n-1}, \u0026 n \u003e 0.\\end{cases}$$\n\t\t- Qual √© o caso-base e o caso recursivo do exemplo acima? #pergunta \n\t- Uma op√ß√£o, que tamb√©m diminui o problema em uma unidade √© $$S(L) = \\begin{cases}0, \u0026 n = 0,\\\\ a_0 + S(L[1:n]), \u0026 n \u003e 0.\\end{cases}$$\n\t\t- Qual √© o caso-base e o caso recursivo do exemplo acima? #pergunta\n\t- Tamb√©m √© poss√≠vel separar o problema ao meio $$S(L) = \\begin{cases}0, \u0026 n = 0,\\\\ a_0, \u0026 n = 1, \\\\ S(L[0:n//2]) + S(L[n//2:n]), \u0026 n \u003e 1.\\\\ \\end{cases}$$\n\t\t- Qual(is) o(s) caso(s)-base e o(s) caso(s) recursivo(s) do exemplo acima? #pergunta \n\t- Os c√≥digos a seguir implementam cada uma das alternativas, respectivamente.\n\t\n```python\ndef sum_first1(L):\n\tn = len(L)\n\tif n == 0:\n\t\treturn 0\n\telse:\n\t\treturn sum_first1(L[0:n-1]) + L[n-1]\n\ndef sum_first2(L):\t\n    if len(L) == 0:\n        return 0\n    else:\n        return L[0] + sum_first2(L[1:])\n\ndef sum_first3(L):\n    n = len(L)\n    if n == 0:\n        return 0\n    elif n == 1:\n        return L[0]\n    else:\n        return sum_first3(L[0:n//2]) + sum_first3(L[n//2:])\n```\n\n### Indu√ß√£o\n\nO termo *indu√ß√£o* √© relacionado a provas matem√°ticas por indu√ß√£o. A ideia principal √© que, ao se desenvolver uma solu√ß√£o recursiva, deve-se assumir que o c√≥digo recursivo j√° funciona para inst√¢ncias menores (mais simples) do problema que se deseja resolver (mesmo que ele ainda n√£o esteja implementado). \n\nUma prova por indu√ß√£o √© composta por duas partes:\n1. O caso-base. Verificar que a f√≥rmula √© v√°lida para o menor caso poss√≠vel $n_0$.\n2. O passo indutivo. Assumir que a f√≥rmula √© verdadeira para um valor gen√©rtico $n$ (hip√≥tese indutiva). Em seguida, usando a hip√≥tese indutiva, mostrar que a f√≥rmula tamb√©m √© v√°lida para $n+1$. \n\nSe for poss√≠vel mostrar os dois passos, ent√£o se diz que a f√≥rmula √© v√°lida para qualquer $n \\geq n_0$.\n\n#### Exemplo de prova por indu√ß√£o\n\nConsidere a seguinte afirma√ß√£o. A soma dos $n$ primeiros n√∫meros positivos $S(n) = \\sum_{i=1}^{i=n} i$   pode ser calculada com a seguinte f√≥rmula $$S(n) = \\frac{n(n+1)}{2}.$$\n1. Caso-base. Para mostrar o caso-base basta verificar que para $n=1$ tem-se $$1 = S(1) = \\frac{1(1+1)}{2}.$$\n2. Para mostrar o passo indutivo √© necess√°rio mostrar que $$S(n+1) = \\frac{(n+1)(n+2)}{2},$$ assumindo que $$S(n) = \\frac{n(n+1)}{2}$$√© verdadeira. Para isso, note que $$S(n+1) = \\sum_{i=1}^n i + (n+1).$$ Mas $\\sum_{i=1}^n i = S(n) = \\frac{n(n+1)}{2}$. Ent√£o, $$S(n+1) = \\sum_{i=1}^n i + (n+1) = \\frac{n(n+1)}{2} + n + 1 = \\frac{n^2 + 3n + 2}{2} = \\frac{(n+1)(n+2)}{2}.$$\nO passo indutivo na prova costuma ser mais complicado, assim como o caso recursivo em um algoritmo recursivo. Quais as semelhan√ßas entre os passos da prova por indu√ß√£o e o desenvolvimento de uma solu√ß√£o recursiva (como as que foram realizadas anteriormente)? #pergunta \n\n\n## Programa√ß√£o imperativa e programa√ß√£o declarativa\n\nOs paradigmas de programa√ß√£o s√£o estrat√©gias gerais para o desenvolvimento de software.\n\n- A programa√ß√£o imperativa se concentrar em definir como os programas funcionam, com o c√≥digo descrevendo examente o fluxo de execu√ß√£o das instru√ß√µes e o estado do programa. Esse √© o paradigma seguido por uma solu√ß√£o iterativa.\n- Uma solu√ß√£o recursiva segue o paradigma declarativo, que se concentrar em definir o que um programa deveria realizar. A programa√ß√£o funcional segue esse conceito.\n\n## Exemplos de problemas\n- [[Torre de Hanoi]]\n- [[Exponencia√ß√£o melhorada]]\n\n# Refer√™ncias\n- Introduction to recursive programming. Sanchez (2019).","lastmodified":"2022-10-19T15:09:54.834727215Z","tags":null},"/vault/estrutura-dados/Torre-de-Hanoi":{"title":"Torre de Hanoi","content":"\n# O problema da Torre de Hanoi\n\n\u003e No grande templo de Benares, abaixo do domo que marca o centro do mundo, repousa uma placa de bronze em que est√£o fixados tr√™s pinos de diamante (...). Em um desses pinos, na cria√ß√£o, Deus colocou 64 discos de puro ouro, o maior disco repousando na placa de bronze, e os seguintes, um menor que o anterior, repousando um em cima do outro. Essa √© a Torre de Brama. Dia e noite, sem descanso, monges transferem os discos de diamante de um pino para o outro de acordo com as leis imut√°veis de Bramah. Essas leis permitem apenas o movimento de um disco por vez e que este disco s√≥ possa ser posto em um pino de forma que n√£o haja disco menor sob ele. Quando os 64 discos tiverem sido transferidos do pino original para um dos demais, torre, templo e o mundo se tornar√° p√≥, e, com um trov√£o, desaparecer√°.(Tradu√ß√£o livre de Hinz, Andreas M., et al. The Tower of Hanoi-Myths and Maths. Basel: Birkh√§user, 2013).\n\n![[vault/estrutura-dados/attachments/Pasted image 20220419154457.png|500]]]\n\n# Um algoritmo\n\n```python\ndef hanoi(n, origin, aux, dest):\n\tif n == 0:\n\t\treturn\n\thanoi(n-1, origin, dest, aux)\n\tprint(\"Disc %d: Moved from %s to %s\" % (n, origin, dest))\n\thanoi(n-1, aux, origin, dest)\nhanoi(3, 'A', 'B', 'C')\n```\n\n### An√°lise da solu√ß√£o\n\nQuantos movimentos $T(n)$ o algoritmo realiza para $n$ discos?\n$$\n\\begin{align*}\n     T(n) \u0026= 2T(n-1) + 1 \\\\\n     \u0026= 4T(n-2) + 3\\\\\n     \u0026= 8T(n-3) + 7\\\\\n     \u0026\\ \\vdots \\\\\n     \u0026= 2^k T(n-k) + 2^k - 1\n\\end{align*}\n$$\n\nPortanto, o algoritmo realiza $O(2^n)$ opera√ß√µes. Mas e ent√£o, quando o mundo ir√° acabar? Em aproximadamente $2^{64}$ movimentos de discos. Supondo que fosse realizado um movimento por segundo, seriam necess√°rios $18446744073709551616 \\approx 1{,}84 \\cdot 10^{19}$ segundos. Qual a idade do universo em segundos? #pergunta \n\n","lastmodified":"2022-10-19T15:09:54.834727215Z","tags":null},"/vault/estrutura-dados/Vis%C3%A3o-geral-de-estrutura-de-dados":{"title":"Vis√£o geral de estrutura da dados","content":"\n\n- [[An√°lise de algoritmos]]\n- [[Recurs√£o]]\n- [[Tipo Abstrato de Dados]]\n- [[Listas ligadas]]\n- [[Pilhas]]\n\t- [[Gerenciamento de mem√≥ria]]\n- [[Filas]]\n- [[Tabelas de s√≠mbolos]]\n\t- [[Tabelas hash]]\n- [[√Årvores]]\n\t- [[vault/estrutura-dados/Percursos em √°rvores |Percursos em √°rvores]]\n\t- [[vault/estrutura-dados/√Årvores bin√°rias |√Årvores bin√°rias]]\n\t\t- [[√Årvores bin√°rias implementadas em vetor]]\n\t\t- [[vault/estrutura-dados/Heaps]]\n\t- [[√Årvores bin√°rias de busca]]\n\t\t- [[√Årvores bin√°rias de busca balanceadas]]\n- [[Grafos]]\n- [[Algoritmos de ordena√ß√£o]]\n- [[Organiza√ß√£o de arquivos]]\n\t- [[√Årvores B]] e [[√Årvores B+]]\n","lastmodified":"2022-10-19T15:09:54.834727215Z","tags":null}}